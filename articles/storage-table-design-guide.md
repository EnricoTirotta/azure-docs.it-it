<properties 
   pageTitle="Azure ストレージ テーブル設計ガイド | Microsoft Azure" 
   description="Azure テーブル ストレージでスケーラビリティとパフォーマンスに優れたテーブルを設計する" 
   services="storage" 
   documentationCenter="na" 
   authors="Tamram,jahogg" 
   manager="adinah" 
   editor=""/>

<tags
   ms.service="storage"
   ms.devlang="na"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="storage" 
   ms.date="02/26/2015"
   ms.author="tamram"/>

# Azure ストレージ テーブル設計ガイド:スケーラビリティとパフォーマンスに優れたテーブルを設計する

## 概要

スケーラビリティとパフォーマンスに優れたテーブルを設計するにあたっては、さまざまな事柄を考慮する必要があります。具体的にはパフォーマンス、スケーラビリティ、コストなどですが、過去にリレーショナル データベースのスキーマを設計した経験がある方なら、こうした考慮事項はご存じであると思われます。しかし、Azure Table サービス ストレージ モデルとリレーショナル モデルには類似の要素が多いとはいえ、重要な違いが多数あるのも事実です。こうした相違点は、リレーショナル データベースの扱いに慣れた方には直感的にわかりづらかったり、扱いづらかったりする設計につながりがちですが、Azure Table サービスなどの NoSQL キー/値ストアを設計する場合には好都合です。Table サービスを設計する際には、数十億ものデータ エンティティ (リレーショナル データベースの用語では "行") を格納できるクラウド規模のアプリケーションや、大量のトランザクションに対応したデータセットをサポートする必要がありますが、設計上の違いの多くはこれを反映したものとなります。したがって、データの格納方法をまったく別のものとして捉えると共に、Table サービスの動作について理解する必要があります。NoSQL データ ストアを適切に設計すれば、リレーショナル データベースを使うソリューションよりも、ソリューションのスケーラビリティが大幅に高まり、コストも抑えられます。このガイドでは、これらのトピックについて説明します。  

## Azure テーブル サービス

このセクションでは、パフォーマンスとスケーラビリティを重視した設計に関連する Table サービスの主要機能を取り上げます。Azure ストレージやテーブル サービスを使用したことがない場合は、この記事を読み進める前に、「[Introduction to Microsoft Azure Storage (Microsoft Azure ストレージの概要)]」や(../storage-introduction/) 「[.NET からテーブル ストレージを使用する方法]」(../storage-dotnet-how-to-use-tables/) をご覧ください。このガイドで主に取り上げるのは Table サービスについてですが、Azure のキューや BLOB サービスと、それらのサービスをソリューションで Table サービスと共に使用する方法についても触れます。  
 
Table サービスとは名前が示すとおり、Table サービスではデータの格納にテーブル形式を使います。標準的な定義では、テーブルの各行はエンティティを表し、そのエンティティの各種プロパティは列に格納されます。各エンティティは、それ自体を一意に識別するためのキーのペアと、Table サービスがエンティティの最終更新日時をトラッキングするためのタイムスタンプ列を持ちます (エンティティの更新は自動的に行われます。タイムスタンプを任意の値を使って手動で上書きすることはできません)。Table サービスでは、この最終更新日時のタイムスタンプ (LMT) を使ってオプティミスティック同時実行を管理します。  

>[AZURE.NOTE] Table サービス REST API の処理では、LMT から派生する **ETag** 値も返されます。このドキュメントでは、ETag と LMT という用語を区別なく使います。基となる同じデータを表しているためです。  

次の例は、従業員と部署のエンティティを格納する、シンプルなテーブル設計を示しています。このガイドで紹介する例の多くは、このシンプルな設計が基になっています。  
 
<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>Timestamp</th>
<th></th>
</tr>
<tr>
<td>Marketing</td>
<td>00001</td>
<td>2014-08-22T00:50:32Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Don</td>
<td>Hall</td>
<td>34</td>
<td>donh@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td>Marketing</td>
<td>00002</td>
<td>2014-08-22T00:50:34Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Jun</td>
<td>Cao</td>
<td>47</td>
<td>junc@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td>Marketing</td>
<td>Department</td>
<td>2014-08-22T00:50:30Z</td>
<td>
<table>
<tr>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td>Marketing</td>
<td>153</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>Sales</td>
<td>00010</td>
<td>2014-08-22T00:50:44Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Ken</td>
<td>Kwok</td>
<td>23</td>
<td>kenk@contoso.com</td>
</tr>
</table>
</td>
</tr>
</table>


今のところ、リレーショナル データベースのテーブルと非常によく似ており、異なるキーが必須の列となっていて、同じテーブルに複数の種類のエンティティを格納できます。さらに、**FirstName** や **Age** などのユーザー定義プロパティには、リレーショナル データベースの列と同様に、integer や string などのデータ型があります。ただし、リレーショナル データベースとは違って、Table サービスにはスキーマがないため、エンティティごとにプロパティのデータ型は同じである必要ありません。1 つのプロパティに複雑なデータ型を格納するには、JSON や XML などのシリアル化された形式を使う必要があります。サポートされているデータ型、サポートされているデータ範囲、名前付け規則、サイズの制限など、Table サービスの詳細については、MSDN で「[テーブル サービス データ モデルについて](http://msdn.microsoft.com/library/azure/dd179338.aspx)」をご覧ください。

この後説明するように、優れたテーブル設計において、**PartitionKey** と **RowKey** の選択が非常に重要になってきます。テーブル内の各エンティティには、**PartitionKey** と **RowKey** の一意の組み合わせが必要です。リレーショナル データベースにおけるキーと同様に、**PartitionKey** と **RowKey** の値はインデックス化され、高速ルックアップを可能にするクラスター化されたインデックスが作成されます。ただし、Table サービスではセカンダリ インデックスが作成されることはないため、インデックス付きのプロパティは 2 つだけになります (後ほど説明するパターンの一部で、この明確な制限に対処する方法を示します)。  

テーブルは 1 つ以上のパーティションで構成されます。この後説明するように、設計上の決定事項の多くは、ソリューションを最適化するために適切な **PartitionKey** と **RowKey** を選ぶことに関係するものです。ソリューションによっては、すべてのエンティティがパーティションを使って整理された 1 つのテーブルだけで構成されるものもありますが、通常は複数のテーブルが含まれます。テーブルを使えばエンティティを論理的に整理できるほか、アクセス制御リストを使ってデータへのアクセスを管理できます。また、1 回のストレージ操作でテーブル全体を削除できます。  

### テーブルのパーティション  
Table サービスがエンティティを格納するストレージ サービス内のパーティションは、アカウント名、テーブル名、**PartitionKey** を組み合わせて識別します。パーティションは、エンティティのアドレス指定スキームの一部であるだけでなく、トランザクションのスコープを定義し (以下の「[エンティティ グループ トランザクション](#entity-group-transactions) 」を参照)、Table サービスのスケーリング方法の基礎となるものでもあります。パーティションの詳細については、「[Azure ストレージのスケーラビリティとパフォーマンスのターゲット](http://msdn.microsoft.com/library/azure/dn249410.aspx)」をご覧ください。  

Table サービスでは、個々のノードが 1 つ以上の完全なパーティションを提供し、サービスのスケーリングはノード間でパーティションの負荷を動的に分散させることで行われます。あるノードの負荷が高まると、Table サービスはそのノードが提供するパーティションの範囲を異なるノードに  *split* できます。トラフィックが収まると、サービスはそのパーティションの範囲をクワイエット ノードから単一のニードに  *merge* できます。  

Table サービスの詳細、特にサービスがパーティションを管理する方法については、「[Microsoft Azure Storage:A Highly Available
Cloud Storage Service with Strong Consistency (Microsoft Azure ストレージ: 強力な整合性を備えた高可用クラウド ストレージ サービス)](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx)」をご覧ください。  

### エンティティ グループ トランザクション 
エンティティ グループ トランザクション (EGT) は、Table サービスで複数のエンティティ間でアトミックな更新を行うための唯一の組み込みのメカニズムです。EGT は、ドキュメントによっては *バッチ トランザクション*とも呼ばれます。EGT では、同じパーティションに格納されたエンティティしか処理できないため (特定のテーブルで同じパーティション キーを共有)、複数のエンティティにまたがるアトミックなトランザクションが必要な場合は、それらのエンティティを同じパーティションに格納する必要があります。これが、異なる種類のエンティティに複数のテーブルを使わずに、異なる種類のエンティティを同じテーブル (とパーティション) に格納する主な理由です。単一の EGT で最大 100 個のエンティティを処理できます。  

EGT により、設計で評価が必要なトレードオフが生じる可能性もあります。使用するパーティションが増えると、ノード間で要求を負荷分散しやすくなるため、アプリケーションのスケーラビリティが向上するものの、アプリケーションでアトミックなトランザクションを実行し、データの強力な一貫性を維持する力が限られるおそれがあります。さらに、パーティションのレベルで固有のスケーラビリティ ターゲットが存在するため、単一のノードに期待できるトランザクションのスループットが制限される可能性があります。Azure ストレージ アカウントと Table サービスのスケーラビリティ ターゲットについては、MSDN で「[Azure Storage のスケーラビリティとパフォーマンスのターゲット](http://msdn.microsoft.com/library/azure/dd179338.aspx)」をご覧ください。このガイドの後のセクションでは、このようなトレードオフを管理しやすくするさまざまな設計戦略を紹介すると共に、クライアント アプリケーションの固有の要件に基づいてパーティション キーを選択する最適な方法についても説明します。  

### 容量に関する考慮事項
次の表に、Table サービス ソリューションの設計時に考慮する必要のある主要な値をまとめます。  

|Azure ストレージ アカウントの合計容量|500 TB|
|------------------------------------------|------|
|Azure のストレージ アカウントのテーブルの数 | ストレージ アカウントの容量のみによる制限 |
|テーブルのパーティションの数 | ストレージ アカウントの容量のみによる制限 |
|パーティション内のエンティティの数 | ストレージ アカウントの容量のみによる制限|
|個別のエンティティのサイズ | 最大で 1 MB、プロパティは最大で 255 個 (**PartitionKey**、**RowKey**、**Timestamp** を含む) |
|**PartitionKey** のサイズ | 最大 1 KB の文字列 |
| **RowKey** のサイズ | 最大 1 KB の文字列 |
|エンティティ グループ トランザクションのサイズ | トランザクションには最大で 100 個のエンティティを含めることができ、ペイロードは 4 MB 未満にする必要があります。EGT では 1 回に 1 つのエンティティしか更新できません。 |

詳細については、MSDN で「[テーブル サービス データ モデルについて](http://msdn.microsoft.com/library/azure/dd179338.aspx)」をご覧ください。  

### コストに関する考慮事項  
テーブル ストレージは比較的安価ですが、テーブル ストレージを使うソリューションの評価の一環として、容量の使用とトランザクションの量を踏まえてコストを見積もる必要があります。ただし、多くのシナリオでは、ソリューションのパフォーマンスとスケーラビリティを向上させるために、非正規化されたデータまたは重複するデータを格納するのも有効です。料金の詳細については、「[ストレージ料金詳細](http://azure.microsoft.com/pricing/details/storage/)」をご覧ください。  

### Azure テーブルと SQL Azure の比較  
Azure SQL Database (リレーショナル データベース サービス) と Table サービスの比較については、MSDN で「[Azure テーブル ストレージと Microsoft Azure SQL Database の比較](http://msdn.microsoft.com/library/azure/jj553018.aspx)」をご覧ください。  

## テーブル設計のガイドライン  
このリストには、テーブルを設計する際に考慮する必要のある主要なガイドラインのうち、いくつかをまとめています。その中身については、後で詳しく説明します。これらのガイドラインは、リレーショナル データベースの設計の際に一般的なガイドラインとは大きく異なっています。  

効率的に  *read* できる Table サービス ソリューションを設計するには: 

-	***読み取り負荷の大きいアプリケーションでのクエリに対応した設計。***テーブルを設計する際には、エンティティの更新方法よりも先に、実行するクエリ (特に遅延時間の影響を受けやすいもの) についてご検討ください。そうすることでソリューションの効率とパフォーマンスが高まります。
-	***クエリで PartitionKey と RowKey を指定。*** *ポイント クエリ* (最も効率的な Table サービス クエリ) など。  
-	***エンティティの重複するコピーの格納を検討する。***テーブル ストレージは安価であるため、クエリの効率を上げるため、(異なるキーを持つ) 同じエンティティを複数回格納することをご検討ください。  
-	***データの非正規化を検討する。***テーブル ストレージは安価であるため、データの非正規化をご検討ください。たとえば、集計データに対するクエリで 1 つのエンティティにアクセスするだけで済むように、サマリ エンティティを格納します。
-	***複合キー値を使用する。***保持しているキーは **PartitionKey** と **RowKey** のみです。たとえば、複合キー値を使用すれば、エンティティへのキーによる代替アクセス パスを使用できるようになります。
-	***クエリ プロジェクションを使用する。***必要なフィールドだけを選択するクエリを使用すれば、ネットワークを介して転送するデータの量を削減できます。

効率的に  *write* できる Table サービス ソリューションを設計するには:   

-	***ホット パーティションを作成しない。***任意の時点で複数のパーティション間に要求を分散させられるようなキーを選びます。
-	***トラフィックの突発的な増加を避ける。***ある程度の期間、トラフィックを平準化し、トラフィックの突発的な増加を避けます。
-	***必要がない場合は、エンティティの種類ごとに個別のテーブルを作成しない。***さまざまな種類のエンティティ間でアトミックなトランザクションが必要な場合は、それらのエンティティを同じテーブルの同じパーティションに格納できます。
-	***実現する必要のある最大スループットを検討する。***テーブル サービスのスケーラビリティ ターゲットを確認し、それを超えない設計にする必要があります。  

このガイドでは、これらの原則を実装した例を紹介します。  

## クエリに対応した設計  
Table サービス ソリューションでは、読み取り、書き込み、またはその両方の負荷が高くなることがあります。このセクションでは、読み取り操作を効率的に行える Table サービスを設計する際に注意する必要のある事柄を中心に取り上げます。通常は、読み取り操作を効率的にサポートする設計は、書き込み操作についても効率が高くなります。ただし、次のセクションの「[データの変更に対応した設計](#design-for-data-modification)」で取り上げるように、書き込み操作をサポートする設計にする場合は、ほかにも考慮する必要のある事柄があります。

データを効率的に読み取ることのできる Table サービス ソリューションを設計する際には、まず "必要なデータを Table サービスから取得するには、アプリケーションでどのようなクエリを実行する必要があるか" を考えてみてください。  

>[AZURE.NOTE] Table サービスを使う場合は、事前に正しく設計することが重要です。後で設計を変更するのは難しいだけでなく、コストも高くなるためです。たとえば、リレーショナル データベースなら、既存のデータベースにインデックスを追加するだけでパフォーマンスの問題に対処できることが多いものの、Table サービスではそうはいきません。  

このセクションでは、クエリに対応したテーブルを設計する際に対処する必要のある主要な問題を中心に取り上げます。このセクションで取り上げるトピックは次のとおりです。  
-	[PartitionKey と RowKey の選択がクエリのパフォーマンスに与える影響](#how-your-choice-of-partitionkey-and-rowkey-impacts-query-performance)
-	[適切な PartitionKey を選ぶ](#choosing-an-appropriate-partitionkey)
-	[Table サービスのキー値ストアによるクエリの最適化](#optimizing-queries-with-a-key-value-store-for-the-table-service)
-	[Table サービスのキー値ストアでデータを並べ替える](#sorting-data-in-a-key-value-store-in-the-table-service)

### PartitionKey と RowKey の選択がクエリのパフォーマンスに与える影響  

次の例では、次の構造の従業員エンティティが Table サービスに格納されると想定しています (わかりやすいように、ほとんどの例で **Timestamp** プロパティは省略してあります)。  

|*列名* |*データ型*|
|--------------|-----------|
|**PartitionKey** (部署名)|文字列|
|**RowKey** (従業員 Id)|文字列|
|**FirstName**|文字列|
|**LastName**|文字列|
|**Age**|整数|
|**EmailAddress**|文字列|

前のセクション「[Azure Table service overview]」(#azure-table-service-overview) では、クエリに対応した設計に直接的な影響を与える Azure Table サービスの主要機能について説明しました。ここから、Table サービスのクエリを設計する際には、次のような一般的なガイドラインが考えられます。ただし、以下の例で使用されているフィルター構文は、Table サービス REST API からのものです。詳細については、MSDN で「[Query Entities](http://msdn.microsoft.com/library/azure/dd179421.aspx)」をご覧ください。  

-	***ポイント クエリ*** は最も効率の良いルックアップであり、大量のルックアップや、遅延を極力抑える必要のあるルックアップに適しています。このようなクエリでは、インデックスを使用して個々のエンティティを非常に効率良く特定します (**PartitionKey** 値と **RowKey** 値の両方を指定)。次に例を示します。
$filter=(PartitionKey eq 'Sales') と (RowKey eq '2')  
-	次にお勧めできるのは***範囲クエリ*** です。このクエリでは、**PartitionKey** を使い、**RowKey** 値の範囲でフィルター処理して複数のエンティティを返します。**PartitionKey** 値で特定のパーティションを識別し、**RowKey** 値でそのパーティション内のエンティティのサブセットを識別します。次に例を示します。
$filter=PartitionKey eq 'Sales' と RowKey ge 'S' and RowKey lt 'T'  
-	3 番目にお勧めできるのは***パーティション スキャン*** です。このタイプでは、**PartitionKey** を使い、キー以外の別のプロパティでフィルター処理します。複数のエンティティが返されることがあります。**PartitionKey** 値で特定のパーティションを識別し、プロパティ値でそのパーティション内のエンティティのサブセットを選択します。次に例を示します。
$filter=PartitionKey eq 'Sales' と LastName eq 'Smith'  
-	***テーブル スキャン*** には **PartitionKey** が含まれず、非常に非効率です。テーブルを構成するすべてのパーティションを検索し、さらに一致するエンティティを検索するためです。フィルターで **RowKey** が使用されているかどうかにかかわらず、テーブル スキャンを実行します。次に例を示します。
$filter=LastName eq 'Jones'  
-	複数のエンティティを返すクエリは、**PartitionKey** と **RowKey** の順で並べ替えたうえで返します。クライアントでエンティティが再度並べ替えられるのを防ぐには、最も一般的な並べ替えの順序を定義する **RowKey** を選択します。  

"**or**" を使用して **RowKey** 値に基づいてフィルターを指定した場合はパーティション スキャンが行われます。範囲クエリとしては扱われません。そのため、
$filter=PartitionKey eq 'Sales' と (RowKey eq '121' or RowKey eq '322')  

ストレージ クライアント ライブラリを使って効率的なクエリを実行するクライアント側コードの例については、  

-	「[ストレージ クライアント ライブラリを使って 1 つのエンティティを取得する]」をご覧ください。(#retrieving-a-single-entity-using-the-storage-client-library)
-	[LINQ を使って複数のエンティティを取得する](#retrieving-multiple-entities-using-linq)
-	[サーバー側のプロジェクション](#server-side-projection)  

同じテーブルに格納された複数の種類のエンティティを処理できるクライアント側コードの例については、  

-	「[異なる種類のエンティティを操作する]」をご覧ください。(#working-with-heterogeneous-entity-types)  

### 適切な PartitionKey を選ぶ  

**PartitionKey** を選ぶ際には、(一貫性の確保の目的で) EGT を使用できるようにする必要性と、(ソリューションのスケーラビリティを高める目的で) エンティティを複数のパーティションに分散させる必要性のバランスを取る必要があります。  

すべてのエンティティを 1 つのパーティションに格納することも可能ですが、そうするとソリューションのスケーラビリティが制限され、Table サービスで要求を負荷分散できなくなる可能性があります。逆に、パーティションごとに 1 つのエンティティを格納することも可能です。そうするとスケーラビリティが高まり、Table サービスで要求を負荷分散できるようになるものの、EGT を使用できなくなります。  

最適な **PartitionKey** は、効率的なクエリを使用できると共に、ソリューションのスケーラビリティを確保できるだけのパーティションがある状態を実現できるものです。通常、エンティティには、十分な数のパーティションにエンティティを分散できるだけのプロパティがあります。  

>[AZURE.NOTE]たとえば、ユーザーまたは従業員に関する情報を格納するシステムでは、ユーザー ID を **PartitionKey** として使うと便利です。  

**PartitionKey** を選ぶ際には、エンティティの挿入、更新、削除の方法に関連する事柄も検討する必要があります。以下の「[データの変更に対応した設計](#design-for-data-modification) 」を参照してください。  

### クエリを Table サービス向けに最適化する  

Table サービスは、**PartitionKey** 値と **RowKey** 値を使用して、単一のクラスター化インデックスにエンティティのインデックスを作成します。これが、ポイント クエリが最も効率的である理由です。ただし、**PartitionKey** と **RowKey** に基づくクラスター化インデックス上のインデックス以外に、インデックスはありません。   

多くの設計は、複数の条件に基づいてエンティティをルックアップできるようにするという要件を満たす必要があります。たとえば、電子メール、従業員 ID、姓に基づいて従業員エンティティを特定する場合などです。「[テーブル設計のパターン]」(#table-design-patterns) セクションで紹介する次のパターンでは、こうした要件を満たすと共に、Table サービスではセカンダリ インデックスが提供されないという弱点を回避する方法を紹介します。  

-	[パーティション内セカンダリ インデックス パターン](#intra-partition-secondary-index-pattern) - 同じパーティション内の異なる **RowKey** 値を使用して各エンティティの複数のコピーを格納することにより、高速で効率の良いルックアップを実現すると共に、異なる **RowKey** 値を使用して並べ替え順を変更できるようにします。  
-	[パーティション間セカンダリ インデックス パターン](#inter-partition-secondary-index-pattern) - 異なるパーティションまたはテーブル内の異なる RowKey 値を使用して各エンティティの複数のコピーを格納することにより、高速で効率の良いルックアップを実現すると共に、異なる **RowKey** 値を使用して並べ替え順を変更できるようにします。  
-	[インデックス エンティティ パターン](#index-entities-pattern) - インデックス エンティティを保持して、エンティティの一覧を返す効率の良い検索を実現します。  

### Table サービスでデータを並べ替える  

Table サービスは、昇順でエンティティを返します。その際、まず基準になるのが **PartitionKey**、その次が **RowKey** です。これらのキーは文字列値であり、数値を正しく並べ替えるには、固定長の値に変換し、ゼロ パディングを施す必要があります。たとえば、**RowKey** として使う従業員 ID の値が整数値である場合、従業員 ID **123** は **00000123** に変換する必要があります。  

さまざまな順序 (名前、入社日など) で並べ替えられたデータを使う必要のあるアプリケーションは多数あります。「[テーブル設計のパターン]」(#table-design-patterns) では、エンティティの並び替え順を変更する方法について説明します。  

-	[パーティション内セカンダリ インデックス パターン](#intra-partition-secondary-index-pattern) - 同じパーティション内の異なる RowKey 値を使用して各エンティティの複数のコピーを格納することにより、高速で効率の良いルックアップを実現すると共に、異なる RowKey 値を使用して並べ替え順を変更できるようにします。  
-	[パーティション間セカンダリ インデックス パターン](#inter-partition-secondary-index-pattern) - 異なるテーブルに含まれる異なるパーティション内の異なる RowKey 値を使用して各エンティティの複数のコピーを格納することにより、高速で効率の良いルックアップを実現すると共に、異なる RowKey 値を使用して並べ替え順を変更できるようにします。 
-	[ログ テール パターン](#log-tail-pattern) - パーティションに追加されたエンティティを、追加日時の新しいものから  *n* 個取得します。その際、**RowKey** 値を使って日時の順序を逆にします。  

## データの変更に対応した設計
このセクションでは、挿入、更新、削除の操作を最適化するための設計上の考慮事項を示します。場合によっては、リレーショナル データベースの設計と同様に、クエリ向けの最適化とデータ変更向けの最適化のトレードオフを評価する必要があります (設計のトレードオフを管理する手法はリレーショナル データベースでは異なります)。「[テーブル設計のパターン]」(#table-design-patterns) セクションでは、Table サービス向けの詳細な設計パターンをいくつか紹介し、こうしたトレードオフについて詳しく説明します。実際のところ、クエリ向けに最適化された設計の多くは、エントリの変更にも適していることがおわかりになると思います。  
 
### 挿入、更新、削除の操作のパフォーマンスを最適化する  

エンティティを更新または削除するには、**PartitionKey** 値と **RowKey** 値を使ってそのエンティティを特定できる必要があります。この点で、エンティティの変更に適した **PartitionKey** と **RowKey** を選ぶ際には、ポイント クエリをサポートするためにキーを選ぶときと似た条件に従うことになります。できるだけ効率良くエンティティを特定できなければならないためです。エンティティの更新や削除に必要となる **PartitionKey** 値と **RowKey** 値を明らかにするために、エンティティの特定に非効率なパーティションまたはテーブル スキャンを使わないようにしてください。  

「[テーブル設計のパターン]」(#table-design-patterns) セクションで紹介する次のパターンでは、挿入、更新、削除の操作のパフォーマンスを最適化する方法を示します。  

-	[大量削除パターン](#high-volume-delete-pattern) - すべてのエンティティを同時削除用に独立したテーブルに格納することで、大量のエンティティを削除できるようにします。エンティティを削除するときは、テーブル自体を削除することになります。  
-	[データ系列パターン](#data-series-pattern) - データ系列全体を単一のエンティティに格納し、要求の数を最小限に抑えます。  
-	[ワイド エンティティ パターン](#wide-entities-pattern) - 複数の物理エンティティを使用して、252 を超えるプロパティを持つ論理エンティティを格納します。  
-	[ラージ エンティティ パターン](#large-entities-pattern) - BLOB ストレージを使用して、大きなプロパティ値を格納します。  

### 格納されたエンティティの一貫性を確保する  

データの変更を最適化するためのキーの選択を左右する要因として、アトミックなトランザクションを使って一貫性を確保する方法も挙げられます。同じパーティションに格納されたエンティティを操作する場合は、EGT を使用します。  

「[テーブル設計のパターン]」(#table-design-patterns) セクションで紹介する次のパターンで、一貫性の管理方法を説明します。  

-	[パーティション内セカンダリ インデックス パターン](#intra-partition-secondary-index-pattern) - 同じパーティション内の異なる **RowKey** 値を使用して各エンティティの複数のコピーを格納することにより、高速で効率の良いルックアップを実現すると共に、異なる **RowKey** 値を使用して並べ替え順を変更できるようにします。  
-	[パーティション間セカンダリ インデックス パターン](#inter-partition-secondary-index-pattern) - 異なるパーティションまたはテーブル内の異なる RowKey 値を使用して各エンティティの複数のコピーを格納することにより、高速で効率の良いルックアップを実現すると共に、異なる **RowKey** 値を使用して並べ替え順を変更できるようにします。  
-	[最終的に一貫性のあるトランザクション パターン](#eventually-consistent-transactions-pattern) - Azure キューを使用して、パーティションやストレージ システムの境界を越えて、最終的に一貫した動作を実現します。
-	[インデックス エンティティ パターン](#index-entities-pattern) - インデックス エンティティを保持して、エンティティの一覧を返す効率の良い検索を実現します。  
-	[非正規化パターン](#denormalization-pattern) - 関連するデータを 1 つのエンティティに結合し、1 回のポイント クエリで必要なデータをすべて取得できるようにします。  
-	[データ系列パターン](#data-series-pattern) - データ系列全体を単一のエンティティに格納し、要求の数を最小限に抑えます。  

EGT の詳細については、「[エンティティ グループ トランザクション]」をご覧ください(#entity-group-transactions)。  

### 効率的な変更に対応した設計によるクエリの効率化  

効率的なクエリに適した設計は変更の効率も高いのが普通ですが、自分のシナリオにもそれが当てはまるかどうかは必ず評価する必要があります。「[テーブル設計のパターン](#table-design-patterns) 」セクションで紹介するパターンの一部では、エンティティのクエリと変更のトレードオフを明確に評価していますが、各タイプの操作の数を必ず考慮する必要があります。  

「[テーブル設計のパターン]」(#table-design-patterns) セクションで紹介する次のパターンでは、効率的なクエリに対応した設計と効率的なデータ変更に対応した設計のトレードオフを取り上げています。  

-	[複合キー パターン](#compound-key-pattern) - 複合 **RowKey** 値を使用して、クライアントが単一のポイント クエリで関連データをルックアップできるようにします。  
-	[ログ テール パターン](#log-tail-pattern) - パーティションに追加されたエンティティを、追加日時の新しいものから  *n* 個取得します。その際、**RowKey** 値を使って日時の順序を逆にします。  

## リレーションシップのモデル化  

複雑なシステムの設計において、ドメイン モデルの作成は重要なステップです。通常は、ビジネス ドメインについて理解し、システムの設計を伝えるための方法として、モデル化プロセスを使用してエンティティとエンティティどうしのリレーションシップを特定します。このセクションでは、ドメイン モデル内の一般的なリレーションシップの種類を Table サービス向けの設計に変換する方法を中心に説明します。論理データ モデルから物理的な NoSQL ベースのデータ モデルへのマッピング プロセスは、リレーショナル データベースの設計時に使われるプロセスとは大きく異なります。リレーショナル データベースの設計は、通常、冗長性を最小限に抑えるために最適化されたデータの正規化プロセスと、データベースの動作の実装方法を抽象化する宣言によるクエリ機能があることを前提としています。  

### 一対多のリレーションシップ  

ビジネス ドメイン オブジェクトの間で一対多のリレーションシップが存在することはよくあります。たとえば、1 つの部署に多数の従業員が存在する場合などです。特定のシナリオにおいて、長短それぞれあるものの、Table サービスに一対多のリレーションシップを実装する方法はいくつかあります。  

何万もの部署と従業員のエンティティがある大規模な多国籍企業の例を考えてみてください。各部署には多数の従業員が在籍しており、各従業員は 1 つの特定の部署に関連付けられています。次のように、部署のエンティティと従業員のエンティティを分けて格納する方法もあります。  

![][1]
 
この例は、**PartitionKey** 値に基づく種類間の一対多のリレーションシップを暗黙的に示しています。各部署に多数の従業員が存在する可能性があります。  

この例は、部署エンティティと、同じパーティションに含まれる関連の従業員エンティティも示しています。別のエンティティの種類として、別のパーティション、テーブル、またはストレージ アカウントを使うこともできます。  

別の方法として、次の例に示すように、データを非正規化し、非正規化された部署データと共に従業員エンティティのみを格納する方法もあります。このシナリオで部署のマネージャーの詳細を変更できるようにする必要がある場合は、この非正規化の方法は最適ではない可能性があります。部署内のすべての従業員を更新する必要が生じるためです。  

![][2]
 
詳細については、このガイドの後半にある「[非正規化のパターン]」(#denormalization-pattern) をご覧ください。  

次の表に、上記で概要を示した一対多のリレーションシップを持つ従業員エンティティと部署エンティティを格納するアプローチについて、それぞれの長所と短所をまとめます。また、各種操作をどの程度の頻度で実行する見込みかも検討する必要があります。コストの高い操作であっても、実行頻度が高くなければ設計に含めてもかまいません。  

<table>
<tr>
<th>アプローチ</th>
<th>長所</th>
<th>短所</th>
</tr>
<tr>
<td>エンティティの種類は別、パーティション、テーブルは同じ</td>
<td>
<ul>
<li>1 回の操作で部署エンティティを更新できる。</li>
<li>従業員エンティティを更新、挿入、削除するたびに部署エンティティを変更する必要がある場合は、一貫性を維持するために EGT を使用できます。たとえば、部署ごとの従業員数を管理する場合などです。</li>
</ul>
</td>
<td>
<ul>
<li>場合によっては、一部のクライアント アクティビティで、従業員エンティティと部署エンティティの両方を取得する必要がある。</li>
<li>ストレージ操作が同じパーティションで行われる。トランザクションの量が多いときにホットスポットが生じる可能性がある。</li>
<li>EGT を使用して従業員を新しい部署に移動できない。</li>
</ul>
</td>
</tr>
<tr>
<td>エンティティの種類は別、パーティション、テーブル、ストレージ アカウントは別</td>
<td>
<ul>
<li>1 回の操作で部署エンティティと従業員エンティティを更新できる。</li>
<li>トランザクションの量が多いときに、負荷をより多くのパーティションに分散させることができる。</li>
</ul>
</td>
<td>
<ul>
<li>場合によっては、一部のクライアント アクティビティで、従業員エンティティと部署エンティティの両方を取得する必要がある。</li>
<li>従業員を更新、挿入、削除し、部署を更新するときに、一貫性を維持するために EGT を使用できる。たとえば、部署エンティティ内の従業員数を更新する場合などです。</li>
<li>EGT を使用して従業員を新しい部署に移動できない。</li>
</ul>
</td>
</tr>
<tr>
<td>単一のエンティティの種類への非正規化</td>
<td>
<ul>
<li>必要なすべての情報を 1 回の要求で取得できる。</li>
</ul>
</td>
<td>
<ul>
<li>部署の情報を更新する必要がある場合、一貫性の維持のコストが高くなる可能性がある (部署のすべての従業員を更新する必要があるため)。</li>
</ul>
</td>
</tr>
</table>
	
これらの選択肢のうちのどれを選ぶかや、どの長所と短所の影響が最も大きいかは、アプリケーションのシナリオによって異なります。たとえば、部署エンティティを変更する頻度、すべての従業員クエリに追加の部署情報が必要かどうか、パーティションまたはストレージ アカウントのスケーラビリティの制限までどのくらいかなどです。  

### 一対一のリレーションシップ  

ドメイン モデルにはエンティティ間の一対一のリレーションシップが含まれることもあります。Table サービスで一対一のリレーションシップを実装する必要がある場合は、2 つの関連するエンティティを取得する必要があるときにそれらをリンクする方法も選択する必要があります。このリンクはキー値の規則に基づいて暗黙的に存在する場合もあるほか、関連エンティティへのリンクを **PartitionKey** 値と **RowKey** 値の形式で各エンティティに格納することで、明示的に設定されることもあります。関連エンティティを同じパーティションに格納する必要があるかどうかについては、「[一対多のリレーションシップ]」をご覧ください(#one-to-many-relationships)。  

実装上の検討内容に応じて、Table サービスで一対一のリレーションシップを実装する必要が生じることもあります。  

-	ラージ エンティティの処理 (詳細については、「[ラージ エンティティの操作]」をご覧ください(#working-with-large-entities))。  
-	アクセス制御の実装 (詳細については、「[Shared Access Signature を使ってアクセスを制御する]」をご覧ください(#controlling-access-with-shared-access-signatures))。  

### クライアントでの結合  

Table サービスでのリレーションシップのモデル化には何とおりかの方法があるものの、Table サービスを使う主な理由はスケーラビリティとパフォーマンスの 2 つであることを忘れないでください。ソリューションのパフォーマンスとスケーラビリティを損なう多数のリレーションシップをモデル化しようとしていることに気が付いた場合は、そのすべてのデータ リレーションシップをテーブル設計に組み込む必要があるかどうかを確認する必要があります。クライアント アプリケーションで必要な結合が実行されるようにすると、設計を簡素化し、ソリューションのスケーラビリティとパフォーマンスを向上させることができます。  

たとえば、変更頻度の高くないデータが格納された小さなテーブルがある場合は、そのデータを取得した後でクライアント上にキャッシュできます。そうすると、何度も同じデータを取得する必要がなくなります。このガイドで見てきた例では、小規模な組織の部署のセットは小さく、変更頻度も低いことが多いので、データをクライアント アプリケーションでダウンロードしてからルックアップ データとしてキャッシュするのに適しています。  

### 継承リレーションシップ  

クライアント アプリケーションでビジネス エンティティを表す継承リレーションシップの一部を構成するクラスのセットを使用する場合は、それらのエンティティを Table サービスで簡単に保持できます。たとえば、クライアント アプリケーションで次のクラスのセットを定義する場合があります (**Person** は抽象クラス)。

![][3]
 
エンティティを次のように扱う 1 つの Person テーブルを使えば、2 つの具象クラスのインスタンスを Table サービスで維持できます。  

![][4]
 
クライアント コードで同じテーブル内の複数の種類のエンティティを操作する方法については、「[異なる種類のエンティティを操作する]」(#working-with-heterogeneous-entity-types) をご覧ください。クライアント コードでエンティティの種類を認識する方法の例が示されています。  

## テーブル設計のパターン
前のセクションでは、クエリを使用してエンティティ データを取得する場合と、エンティティ データを挿入、更新、削除する場合の両方のテーブル設計を最適化する方法について詳しく説明しました。このセクションでは、Table サービス ソリューションで使用するのに適したパターンをいくつか紹介します。また、このガイドで前に提起された問題とトレードオフの一部に実際に対処する方法を説明しています。次の図は、さまざまなパターンの関係をまとめたものです。  

![][5]
 
上記のパターン マップには、このガイドに記載されているパターン (青) とアンチパターン (オレンジ) の関係の一部が示されています。もちろん、検討する価値があるパターンは他にもたくさんあります。たとえば、Table サービスの主なシナリオの 1 つでは、[コマンド クエリ責務分離](https://msdn.microsoft.com/library/azure/jj554200.aspx) (CQRS) パターンから[具体化されたビュー](https://msdn.microsoft.com/library/azure/dn589782.aspx)を格納します。  

### パーティション内セカンダリ インデックス パターン
同じパーティション内の異なる **RowKey** 値を使用して各エンティティの複数のコピーを格納することにより、高速で効率の良いルックアップを実現すると共に、異なる **RowKey** 値を使用して並べ替え順を変更できるようにします。コピー間の更新の一貫性は、EGT を使用して保つことができます。  

#### コンテキストと問題
Table サービスにより、**PartitionKey** 値と **RowKey** 値を使用してエンティティのインデックスが自動的に作成されます。そのため、クライアント アプリケーションでは、これらの値を使用してエンティティを効率的に取得できます。たとえば、以下のテーブル構造を使用した場合、クライアント アプリケーションでは、ポイント クエリで部署名と従業員 ID (**PartitionKey** 値と **RowKey** 値) を使用して、個々の従業員エンティティを取得できます。また、各部署内の従業員 ID で並べ替えたエンティティを取得することも可能です。

![][6]
 
また、電子メール アドレスなど、他のプロパティの値に基づいて従業員エンティティを検索できるようにする場合は、効率の劣るパーティション スキャンを使用して、一致するエンティティを検索する必要があります。これは、Table サービスではセカンダリ インデックスが提供されないためです。また、**RowKey** の順序とは異なる順序で並べ替えられた従業員の一覧を要求する方法はありません。  

#### ソリューション
セカンダリ インデックスが提供されない問題を回避するために、各エンティティのコピーを複数格納し、コピーごとに異なる **RowKey** 値を使用します。以下の構造でエンティティを格納した場合は、電子メール アドレスまたは従業員 ID に基づいて従業員エンティティを効率的に取得できます。**RowKey** のプレフィックス値 "empid_" と "email_" を使用すると、1 人の従業員を照会することや、電子メール アドレスまたは従業員 ID の範囲を指定して一連の従業員を照会できます。  

![][7]
 
次の 2 つのフィルター条件 (従業員 ID で検索するフィルター条件と電子メール アドレスで検索するフィルター条件) ではどちらもポイント クエリを指定しています。  

-	$filter=(PartitionKey eq 'Sales') and (RowKey eq 'empid_000223')  
-	$filter=(PartitionKey eq 'Sales') and (RowKey eq 'email_jonesj@contoso.com')  

一連の従業員エンティティを照会する場合は、従業員 ID 順に並べ替えられた範囲を指定するか、**RowKey** の適切なプレフィックスを使用してエンティティを照会することで電子メール アドレス順に並べ替えられた範囲を指定できます。  

-	Sales 部署で従業員 ID が 000100 ～ 000199 の範囲のすべての従業員を検索するには、次の条件を使用します。
$filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000100') and (RowKey le 'empid_000199')  
-	Sales 部署で電子メール アドレスが 'a' という文字で始まるすべての従業員を検索するには、次の条件を使用します。
$filter=(PartitionKey eq 'Sales') と (RowKey ge 'email_a') と (RowKey lt 'email_b')  

 上の例で使用しているフィルター構文は、Table サービス REST API の構文です。詳細については、MSDN の「[Query Entities](http://msdn.microsoft.com/library/azure/dd179421.aspx)」をご覧ください。  

#### 問題と注意事項  

このパターンの実装方法を決めるときには、以下の点に注意してください。  

-	テーブル ストレージは比較的低コストで利用できるため、重複するデータを格納してもコストは大きな問題になりません。ただし、必ず、予想されるストレージ要件に基づいて設計のコストを見積もり、クライアント アプリケーションが実行するクエリで使用するエンティティのみを複製する必要があります。  
-	セカンダリ インデックス エンティティは元のエンティティと同じパーティションに格納されるため、個々のパーティションのスケーラビリティ ターゲットを超えないようにする必要があります。  
-	EGT を使用してエンティティの 2 つのコピーをアトミックに更新することで、重複するエンティティどうしの一貫性を保つことができます。そのためには、エンティティのすべてのコピーを同じパーティションに格納する必要があります。詳細については、[エンティティ グループ トランザクションの使用]に関するセクションをご覧ください(#entity-group-transactions)。  
-	**RowKey** に使用する値は、各エンティティに対して一意である必要があります。複合キー値の使用を検討してください。  
-	従業員 ID 000223 のように、**RowKey** の数値をパディングすると、上限と下限に基づいて正しく並べ替えることやフィルター処理できます。  
-	必ずしもエンティティのすべてのプロパティを複製する必要はありません。たとえば、**RowKey** の電子メール アドレスを使用してエンティティを検索するクエリで従業員の年齢がまったく必要ない場合、これらのエンティティは以下の構造にすることができます。

![][8]
 
-	通常は、エンティティの検索と必要なデータの検索にそれぞれ異なるクエリを使用するよりも、重複するデータを格納し、必要なすべてのデータを単一のクエリで取得できるようにすることをお勧めします。  

#### このパターンを使用する状況  

クライアント アプリケーションで異なるさまざまなキーを使用してエンティティを取得する必要がある場合、クライアントで異なる順序で並べ替えたエンティティを取得する必要がある場合、さまざまな一意の値を使用して各エンティティを識別できる場合に、このパターンを使用します。ただし、異なる **RowKey** 値を使用してエンティティの検索を実行する際に、パーティションのスケーラビリティの限界を超えないようにする必要があります。  

#### 関連のあるパターンとガイダンス  

このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  
 
-	[パーティション間セカンダリ インデックス パターン](#inter-partition-secondary-index-pattern)
-	[複合キー パターン](#compound-key-pattern)
-	[エンティティ グループ トランザクション](#entity-group-transactions)
-	[異なる種類のエンティティを操作する](#working-with-heterogeneous-entity-types)

### パーティション間セカンダリ インデックス パターン
異なるパーティションまたはテーブル内の異なる **RowKey** 値を使用して各エンティティの複数のコピーを格納することにより、高速で効率の良いルックアップを実現すると共に、異なる **RowKey** 値を使用して並べ替え順を変更できるようにします。  

#### コンテキストと問題
Table サービスにより、**PartitionKey** 値と **RowKey** 値を使用してエンティティのインデックスが自動的に作成されます。そのため、クライアント アプリケーションでは、これらの値を使用してエンティティを効率的に取得できます。たとえば、以下のテーブル構造を使用した場合、クライアント アプリケーションでは、ポイント クエリで部署名と従業員 ID (**PartitionKey** 値と **RowKey** 値) を使用して、個々の従業員エンティティを取得できます。また、各部署内の従業員 ID で並べ替えたエンティティを取得することも可能です。  

![][9]
 
また、電子メール アドレスなど、他のプロパティの値に基づいて従業員エンティティを検索できるようにする場合は、効率の劣るパーティション スキャンを使用して、一致するエンティティを検索する必要があります。これは、Table サービスではセカンダリ インデックスが提供されないためです。また、**RowKey** の順序とは異なる順序で並べ替えられた従業員の一覧を要求する方法はありません。  

これらのエンティティに対するトランザクションの量が膨大になることが予想される場合は、Table サービスによってクライアントが調整されるリスクを最小限に抑える必要があります。  

#### ソリューション  
セカンダリ インデックスが提供されない問題を回避するために、各エンティティのコピーを複数格納し、コピーごとに異なる **PartitionKey** 値と **RowKey** 値を使用できます。以下の構造のエンティティを格納した場合は、電子メール アドレスまたは従業員 ID に基づいて従業員エンティティを効率的に取得できます。**PartitionKey** のプレフィックス値 "empid_" と "email_" を使用すると、クエリに使用するインデックスを特定できます。  

![][10]
 
次の 2 つのフィルター条件 (従業員 ID で検索するフィルター条件と電子メール アドレスで検索するフィルター条件) ではどちらもポイント クエリを指定しています。  

-	$filter=(PartitionKey eq 'empid_Sales') and (RowKey eq '000223')
-	$filter=(PartitionKey eq 'email_Sales') and (RowKey eq 'jonesj@contoso.com')  

一連の従業員エンティティを照会する場合は、従業員 ID 順に並べ替えられた範囲を指定するか、**RowKey** の適切なプレフィックスを使用してエンティティを照会することで電子メール アドレス順に並べ替えられた範囲を指定できます。  

-	Sales 部署で従業員 ID が **000100** ～ **000199** の範囲のすべての従業員を従業員 ID 順に並べ替えて検索するには、次の条件を使用します。 
$filter=(PartitionKey eq 'empid_Sales') and (RowKey ge '000100') and (RowKey le '000199')  
-	Sales 部署で電子メール アドレスが 'a' で始まるすべての従業員を従業員 ID 順に並べ替えて検索するには、次の条件を使用します。
$filter=(PartitionKey eq 'email_Sales') と (RowKey ge 'a') and (RowKey lt 'b')  

上の例で使用しているフィルター構文は、Table サービス REST API の構文です。詳細については、MSDN の「[Query Entities](http://msdn.microsoft.com/library/azure/dd179421.aspx)」をご覧ください。  

#### 問題と注意事項  
このパターンの実装方法を決めるときには、以下の点に注意してください。  

-	[最終的に一貫性のあるトランザクション パターン]を使用してプライマリとセカンダリ インデックス エンティティを管理すると、(#eventually-consistent-transactions-pattern) 重複するエンティティどうしの一貫性を最終的に確保できます。  
-	テーブル ストレージは比較的低コストで利用できるため、重複するデータを格納してもコストは大きな問題になりません。ただし、必ず、予想されるストレージ要件に基づいて設計のコストを見積もり、クライアント アプリケーションが実行するクエリで使用するエンティティのみを複製する必要があります。  
-	**RowKey** に使用する値は、各エンティティに対して一意である必要があります。複合キー値の使用を検討してください。  
-	従業員 ID 000223 のように、**RowKey** の数値をパディングすると、上限と下限に基づいて正しく並べ替えることやフィルター処理できます。  
-	必ずしもエンティティのすべてのプロパティを複製する必要はありません。たとえば、**RowKey** の電子メール アドレスを使用してエンティティを検索するクエリで従業員の年齢がまったく必要ない場合、これらのエンティティは以下の構造にすることができます。

	![][11]
 
-	通常は、セカンダリ インデックスを使用したエンティティの検索とプライマリ インデックス内の必要なデータの検索にそれぞれ異なるクエリを使用するよりも、重複するデータを格納し、必要なすべてのデータを単一のクエリで取得できるようにすることをお勧めします。  

#### このパターンを使用する状況  
クライアント アプリケーションで異なるさまざまなキーを使用してエンティティを取得する必要がある場合、クライアントで異なる順序で並べ替えたエンティティを取得する必要がある場合、さまざまな一意の値を使用して各エンティティを識別できる場合に、このパターンを使用します。異なる **RowKey** 値を使用してエンティティの検索を実行する際にパーティションのスケーラビリティの限界を超えないようにする必要がある場合も、このパターンを使用します。  

#### 関連のあるパターンとガイダンス
このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  
 
-	[最終的に一貫性のあるトランザクション パターン](#eventually-consistent-transactions-pattern)  
-	[パーティション内セカンダリ インデックス パターン](#intra-partition-secondary-index-pattern)  
-	[複合キー パターン](#compound-key-pattern)  
-	[エンティティ グループ トランザクション](#entity-group-transactions)  
-	[異なる種類のエンティティを操作する](#working-with-heterogeneous-entity-types)  

### 最終的に一貫性のあるトランザクション パターン  

Azure キューを使用して、パーティションやストレージ システムの境界を越えて、最終的に一貫した動作を実現します。  

#### コンテキストと問題  

EGT を使用すると、同じパーティション キーを共有する複数のエンティティに対してアトミックなトランザクションを実行できます。パフォーマンスやスケーラビリティの関係で、一貫性が必要なエンティティを別々のパーティションや別のストレージ システムに格納する場合があります。そのような場合は、EGT を使用して一貫性を保つことはできません。たとえば、次の一貫性を最終的に確保する必要があるとします。  

-	同じテーブル内の 2 つの異なるパーティション、異なるテーブル、異なるストレージ アカウントに格納されているエンティティ。  
-	Table サービスに格納されているエンティティと BLOB サービスに格納されている BLOB。  
-	Table サービスに格納されているエンティティとファイル システム内のファイル。  
-	Table サービスに格納されているにもかかわらず、Azure Search サービスを使用してインデックスが作成されているエンティティ。  

#### ソリューション  

Azure キューを使用すると、2 つ以上のパーティションまたはストレージ システム間で最終的に一貫性を確保するソリューションを実装できます。
この方法を説明するために、退職した従業員エンティティをアーカイブできるようにする必要があるとします。退職した従業員エンティティはめったに照会されず、現在の従業員を対象にしたすべてのアクティビティから除外する必要があります。この要件を実装するには、**Current** テーブルに現在の従業員を格納し、**Archive** テーブルに退職した従業員を格納します。従業員をアーカイブする場合は、**Current** テーブルからエンティティを削除し、そのエンティティを **Archive** テーブルに追加する必要があります。ただし、EGT を使用してこの 2 つの操作を行うことはできません。エンティティが両方のテーブルに表示されることや、どちらのテーブルにも表示されないことがないように、アーカイブ操作は最終的に一貫性が確保される必要があります。次のシーケンス図は、この操作の大まかな手順を示しています。その下のテキストには、例外パスの詳細が示されています。  

![][12]
 
クライアントは、Azure キューにメッセージを配置することによって、アーカイブ操作を開始します。この例では、ID が 456 の従業員をアーカイブします。worker ロールは、キューをポーリングして新しいメッセージの有無を確認します。メッセージを見つけると、そのメッセージを読み取り、隠しコピーをキューに残します。worker ロールは、次に、**Current** テーブルからエンティティのコピーをフェッチし、**Archive** テーブルにコピーを挿入した後、**Current** テーブルから元のエンティティを削除します。最後に、前の手順でエラーが発生しなければ、worker ロールはキューから隠しメッセージを削除します。  

この例では、手順 4. で、**Archive** テーブルに従業員を挿入しています。BLOB サービスの BLOB またはファイル システム内のファイルに従業員を加えることもできます。  

#### エラーからの回復  

worker ロールがアーカイブ操作を再実行する必要がある場合に備えて、手順 **4** と **5** の操作は必ず  *idempotent* であることが重要です。Table サービスを使用する場合は、手順 **4**. では "挿入または置換" 操作を使用し、手順 **5**. では使用しているクライアント ライブラリの "存在する場合に削除" 操作を使用する必要があります。他のストレージ システムを使用する場合は、適切なべき等操作を使用する必要があります。  

worker ロールが手順 **6**. をまったく完了しない場合は、タイムアウト後、worker ロールがメッセージの再処理を試行できるようにそのメッセージがキューに再度配置されます。worker ロールは、キュー上のメッセージを読み取った回数を確認し、必要に応じて、別のキューに送信することで、調査のために "有害" メッセージとしてフラグを設定できます。キュー メッセージの読み取りとデキュー カウントの確認の詳細については、「[Get Messages](https://msdn.microsoft.com/library/azure/dd179474.aspx)」をご覧ください。  

Table サービスと Queue サービスのエラーには一時的なエラーもあります。クライアント アプリケーションには、そうしたエラーに対処する適切な再試行ロジックを組み込む必要があります。  

#### 問題と注意事項
このパターンの実装方法を決めるときには、以下の点に注意してください。  

-	このソリューションは、トランザクションを分離するためのソリューションではありません。たとえば、worker ロールが手順 **4**. と **5**. の間にさしかかったときに、クライアントで **Current** テーブルと **Archive** テーブルを読み取って、一貫性のないデータのビューを表示できます。データは最終的に一貫性が確保されます。  
-	最終的に一貫性を確保するために、手順 4. と 5. がべき等になっていることを確認する必要があります。  
-	複数のキューと worker ロール インスタンスを使用して、ソリューションを拡張できます。  

#### このパターンを使用する状況  
別のパーティションまたはテーブルに存在するエンティティ間の一貫性を最終的に確保する必要がある場合に、このパターンを使用します。このパターンを拡張して、Table サービスと BLOB サービスのほかにも、データベースやファイル システムなどの Azure 以外のストレージ データ ソース間の操作で最終的な一貫性を確保できます。  

#### 関連のあるパターンとガイダンス  
このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  
-	[エンティティ グループ トランザクション](#entity-group-transactions)  
-	[マージまたは置換](#merge-or-replace)  

>[AZURE.NOTE] ソリューションにとってトランザクションの分離が重要な場合は、EGT を使用できるようにテーブルを再設計することを検討する必要があります。  

### インデックス エンティティ パターン
インデックス エンティティを保持して、エンティティの一覧を返す効率の良い検索を実現します。  

#### コンテキストと問題  

Table サービスにより、**PartitionKey** 値と **RowKey** 値を使用してエンティティのインデックスが自動的に作成されます。そうすると、クライアント アプリケーションでポイント クエリを使用してエンティティを効率的に取得できます。たとえば、以下のテーブル構造を使用した場合、クライアント アプリケーションでは、部署名と従業員 ID (**PartitionKey** と **RowKey**) を使用して、個々の従業員エンティティを効率的に取得できます。  
 
![][13]

また、姓など、一意ではない他のプロパティの値に基づいて従業員エンティティの一覧を取得できるようにする場合は、インデックスを使用して直接一致するエンティティを検索せずに、効率の劣るパーティション スキャンを使用して検索する必要があります。これは、Table サービスではセカンダリ インデックスが提供されないためです。  

#### ソリューション  

上のエンティティ構造の場合、姓で検索できるようにするには、従業員 ID の一覧を保持する必要があります。Jones など、特定の姓を持つ従業員エンティティを取得するには、まず姓が Jones である従業員の従業員 ID の一覧を検索してから、それらの従業員エンティティを取得する必要があります。従業員 ID の一覧を格納する方法は主に次の 3 つがあります。  

-	BLOB ストレージを使用する。  
-	従業員エンティティと同じパーティションにインデックス エンティティを作成する。  
-	別のパーティションまたはテーブルにインデックス エンティティを作成する。  

<u>手順 #1:BLOB ストレージを使用する</u>  

最初の方法では、一意の姓ごとに BLOB を作成し、各 BLOB に、その姓を持つ従業員の **PartitionKey** (部署) 値と **RowKey** (従業員 ID) 値の一覧を格納します。従業員を追加または削除した場合は、関連する BLOB の内容と従業員エンティティの一貫性が最終的に確保されていることを確認する必要があります。  

<u>手順 #2:</u> 同じパーティションにインデックス エンティティを作成する  

2 番目の方法では、以下のデータを格納するインデックス エンティティを使用します。  

![][14]
 
**EmployeeIDs** プロパティには、**RowKey** に格納されている姓を持つ従業員の従業員 ID の一覧が含まれています。  

次の手順は、2 番目の方法を使用した場合に、新しい従業員を追加するときに従う必要がある手順の概要を示しています。この例では、Sales 部署で ID が 000152、姓が Jones の従業員を追加します。  
1.	**PartitionKey** 値が "Sales" で **RowKey** 値が "Jones" のインデックス エンティティを取得します。このエンティティの ETag を、手順 2. で使用するために保存します。  
2.	新しい従業員エンティティ (**PartitionKey** 値が "Sales"、**RowKey** 値が "000152") を挿入し、EmployeeIDs フィールドの一覧に新しい従業員 ID を追加することによってインデックス エンティティ (**PartitionKey** 値が "Sales"、**RowKey** 値が "Jones") を更新する EGT を作成します。  
3.	オプティミスティック同時実行エラー (他のユーザーがインデックス エンティティを変更したこと) が原因で ETG が失敗した場合は、手順 1. からまたやり直す必要があります。  

2 番目の方法を使用する場合は、同じような方法で従業員を削除できます。従業員の姓を変更するのは、3 つのエンティティ (従業員エンティティ、元の姓のインデックス エンティティ、新しい姓のインデックス エンティティ) を更新する ETG を実行する必要があるため、少し複雑です。変更を加える前に、各エンティティを取得して、ETag 値を取得する必要があります。その ETag 値を使用して、オプティミスティック同時実行で更新を実行できます。  

次の手順は、2 番目の方法を使用した場合に、ある部署で特定の姓を持つすべての従業員を検索する必要があるときに従う必要がある手順の概要を示しています。この例では、Sales 部署で姓が Jones のすべての従業員を検索します。  

1.	**PartitionKey** 値が "Sales" で **RowKey** 値が "Jones" のインデックス エンティティを取得します。  
2.	EmployeeIDs フィールドで従業員 ID の一覧を解析します。  
3.	これらの各従業員の追加情報 (電子メール アドレスなど) が必要な場合は、手順 2. で取得した従業員の一覧から **PartitionKey** 値 "Sales" と **RowKey** 値を使用して各従業員エンティティを取得します。  

<u>手順 #3:</u> 別のパーティションやテーブルにインデックス エンティティを作成する  

3 番目の方法では、以下のデータを格納するインデックス エンティティを使用します。  

![][15]
 
**EmployeeIDs** プロパティには、**RowKey** に格納されている姓を持つ従業員の従業員 ID の一覧が含まれています。  

3 番目の方法では、インデックス エンティティが従業員エンティティとは別のパーティションにあるため、EGT を使用して一貫性を保つことはできません。インデックス エンティティが従業員エンティティと最終的に一貫していることを確認する必要があります。  

#### 問題と注意事項  

このパターンの実装方法を決めるときには、以下の点に注意してください。  
-	このソリューションでは、一致するエンティティを取得するために、少なくとも 2 つのクエリが必要です。1 つはインデックス エンティティを照会して **RowKey** 値の一覧を取得するクエリです。もう 1 つはその一覧内の各エンティティを取得するクエリです。  
-	個々のエンティティの最大サイズは 1 MB であるため、ソリューションの方法 2 と方法 3 では、特定の姓の従業員 ID の一覧が 1 MB を超えることがないと仮定しています。従業員 ID の一覧のサイズが 1 MB を超える可能性がある場合は、方法 1 を使用して、BLOB ストレージにインデックス データを格納します。  
-	方法 2 を使用する (EGT を使用して、従業員の追加と削除、従業員の姓の変更を処理する) 場合は、トランザクションの量が特定のパーティションのスケーラビリティの限界に近づくかどうかを確認する必要があります。限界に近づく場合は、キューを使用して更新要求を処理し、従業員エンティティとは別のパーティションにインデックス エンティティを格納でき、最終的に一貫性が確保されるソリューション (方法 1 または方法 3) を検討する必要があります。  
-	このソリューションの方法 2 では、部署内を姓で検索する (たとえば、Sales 部署で姓が Jones の従業員の一覧を取得する) 必要があると想定しています。組織全体で姓が Jones のすべての従業員を検索できる必要がある場合は、方法 1 と方法 3 のどちらかを使用します。   
-	最終的に一貫性が確保されるキュー ベースのソリューションを実装できます (詳細については、「[最終的に一貫性のあるトランザクション パターン]」を(#eventually-consistent-transactions-pattern) ご覧ください)。  

#### このパターンを使用する状況  

姓が Jones のすべての従業員など、特定のプロパティ値がすべて共通している一連のエンティティを検索する場合に、このパターンを使用します。  

#### 関連のあるパターンとガイダンス  

このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  
-	[複合キー パターン](#compound-key-pattern)  
-	[最終的に一貫性のあるトランザクション パターン](#eventually-consistent-transactions-pattern)  
-	[エンティティ グループ トランザクション](#entity-group-transactions)  
-	[異なる種類のエンティティを操作する](#working-with-heterogeneous-entity-types)  

### 非正規化パターン  

関連するデータを 1 つのエンティティに結合し、1 回のポイント クエリで必要なデータをすべて取得できるようにします。  

#### コンテキストと問題  

リレーショナル データベースでは、通常、重複を排除するためにデータを正規化します。その結果、クエリで複数のテーブルからデータを取得することになります。Azure テーブルのデータを正規化した場合、関連するデータを取得するには、クライアント アプリケーションとサーバー間のラウンド トリップを複数回行う必要があります。たとえば、以下のテーブル構造を使用した場合、部署の詳細を取得するためには、2 回ラウンド トリップを行う必要があります。1 回目のラウンド トリップでマネージャーの ID を含む部署エンティティをフェッチし、2 回目で従業員エンティティからマネージャーの詳細をフェッチします。  

![][16]
 
#### ソリューション  

データを 2 つのエンティティに格納する代わりに、データを非正規化し、部署エンティティにマネージャーの詳細のコピーを保持します。次に例を示します。  

![][17]
 
格納されている部署エンティティにはこれらのプロパティがあるため、ポイント クエリを使用して、部署に関する必要なすべての詳細を取得できます。  

#### 問題と注意事項  

このパターンの実装方法を決めるときには、以下の点に注意してください。  

-	一部のデータを重複して格納するため、多少コストがかかります。通常、ストレージ コストの増加はわずかなため、(ストレージ サービスへの要求が減少することによる) パフォーマンス上のメリットが勝ります (このコストの一部は、部署の詳細をフェッチするために必要なトランザクションの数が減少することで相殺されます)。  
-	マネージャーに関する情報を格納する 2 つのエンティティの一貫性を維持する必要があります。一貫性の問題は、EGT を使用して単一のアトミックなトランザクションで複数のエンティティを更新することで対処できます。この例では、部署エンティティと、部署マネージャーの従業員エンティティが同じパーティションに格納されています。  

#### このパターンを使用する状況
関連情報を頻繁に検索する必要がある場合に、このパターンを使用します。このパターンを使用すると、クライアントが必要なデータを取得するために実行する必要があるクエリの数が減少します。  

#### 関連のあるパターンとガイダンス
このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  
-	[複合キー パターン](#compound-key-pattern)  
-	[エンティティ グループ トランザクション](#entity-group-transactions)  
-	[異なる種類のエンティティを操作する](#working-with-heterogeneous-entity-types)   

### 複合キー パターン  

複合 **RowKey** 値を使用して、クライアントが単一のポイント クエリで関連データをルックアップできるようにします。  

#### コンテキストと問題  

リレーショナル データベースでは、単一のクエリで関連するデータをクライアントに返すために、クエリでよく結合を使用します。たとえば、従業員 ID を使用して、その従業員の業績と評価データが含まれている関連エンティティの一覧を検索する場合があります。  

次の構造を使用し、Table サービスに従業員エンティティを格納しているとします。  

![][18]
 
また、各年度の従業員の評価と業績に関する履歴データを格納し、この情報に年度別でアクセスできる必要もあります。それには、次の構造でエンティティを格納する別のテーブルを作成するという方法があります。  

![][19]
 
この方法では、単一の要求でデータを取得できるようにするには、一部の情報 (姓や名など) を新しいエンティティに複製する必要があります。ただし、EGT を使用しても 2 つのエンティティをアトミックには更新できないため、強力な整合性を保つことはできません。  

#### ソリューション
次の構造のエンティティを使用して、元のテーブルに新しい種類のエンティティを格納します。  

![][20]
 
**RowKey** が従業員 ID と評価データの年度で構成された複合キーになっていることに注目してください。そのため、単一のエンティティに対する単一の要求で従業員の業績と評価データを取得できます。  

次の例では、Sales 部署の従業員 000123 など、特定の従業員のすべての評価データを取得する方法を示しています。  

$filter=(PartitionKey eq 'Sales')、(RowKey ge 'empid_000123')、(RowKey lt 'empid_000124')&$select=RowKey,Manager Rating,Peer Rating,Comments  

#### 問題と注意事項
このパターンの実装方法を決めるときには、以下の点に注意してください。  

-	**000123_2012** のように、**RowKey** 値を簡単に解析できるように適切な区切り文字を使用する必要があります。  
-	また、このエンティティは、同じ従業員の関連データを含む他のエンティティと同じパーティションに格納します。そうすると、EGT を使用して、強い整合性を維持できます。
-	このパターンが適切であるかどうかを判断には、データを照会する頻度を考慮する必要があります。たとえば、評価データにはあまり頻度にアクセスせず、メインの従業員データには頻度にアクセスする場合は、それらのデータを別々のエンティティとして保持する必要があります。  

#### このパターンを使用する状況  

頻繁に照会する関連エンティティを 1 つ以上格納する必要がある場合に、このパターンを使用します。  

#### 関連のあるパターンとガイダンス  

このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

-	[エンティティ グループ トランザクション](#entity-group-transactions)  
-	[異なる種類のエンティティを操作する](#working-with-heterogeneous-entity-types)  
-	[最終的に一貫性のあるトランザクション パターン](#eventually-consistent-transactions-pattern)  

### ログ テール パターン  

パーティションに追加されたエンティティを、追加日時の新しいものから  *n* 個取得します。その際、**RowKey** 値を使って日時の順序を逆にします。  

#### コンテキストと問題  

よく、最近作成されたエンティティ (従業員が提出した経費請求を日時の新しいものから 10 件など) を取得できることが必要な場合があります。テーブル クエリでは、一連のデータから最初の  *n* 個のエンティティを返す **$top** クエリ操作をサポートしています。一連のデータの最後の n 個のエンティティを返す同等のクエリ操作はありません。  

#### ソリューション  

**RowKey** を使って日時の順序を逆にしてエンティティを格納し、最新のエントリが常にテーブルの最初のエントリになるようにします。  

たとえば、従業員が提出した経費請求を日時の新しいものから 10 件取得できるようにする場合は、現在の日時から派生した逆順のティック値を使用できます。次の C# コード サンプルでは、日時の新しいもの順に並べ替える **RowKey** の適切な "逆順のティック" 値を作成する方法の 1 つを示しています。  

`string invertedTicks = string.Format("{0:D19}", DateTime.MaxValue.Ticks - DateTime.UtcNow.Ticks);`  

次のコードを使用すると、日時値に戻すことができます。  

`DateTime dt = new DateTime(DateTime.MaxValue.Ticks - Int64.Parse(invertedTicks));`  

テーブル クエリは次のようになります。  

`https://myaccount.table.core.windows.net/EmployeeExpense(PartitionKey='empid')?$top=10`  

#### 問題と注意事項  

このパターンの実装方法を決めるときには、以下の点に注意してください。  

-	文字列値が正しく並び替わるように、逆順のティック値の先頭にゼロをパディングする必要があります。  
-	パーティション レベルのスケーラビリティ ターゲットに注意する必要があります。ホット スポット パーティションが発生しないように注意してください。  

#### このパターンを使用する状況  

日時の逆順でエンティティにアクセスする必要がある場合、または追加日時の新しい順にエンティティにアクセスする必要がある場合に、このパターンを使用します。  

#### 関連のあるパターンとガイダンス  

このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

-	[先頭または末尾に追加するアンチパターン](#prepend-append-anti-pattern)  
-	[エンティティを取得する](#retrieving-entities)  

### 大量削除パターン  

すべてのエンティティを同時削除用に独立したテーブルに格納することで、大量のエンティティを削除できるようにします。エンティティを削除するときは、テーブル自体を削除することになります。  

#### コンテキストと問題  

多くのアプリケーションでは、クライアント アプリケーションで使用する必要がなくなった古いデータや、他の記憶域メディアにアーカイブした古いデータを削除します。通常は、日付でそうしたデータを特定します。たとえば、60 日以上前のすべてのログイン要求のレコードを削除する必要があるとします。  

考えられる設計の 1 つとして、**RowKey** のログイン要求の日時を使用します。  
 
![][21]

この方法では、アプリケーションが別のパーティションで各ユーザーのログイン エンティティを挿入したり削除したりできるため、パーティションのホット スポットを回避できます。ただし、まず削除するすべてのエンティティを特定するためにテーブル スキャンを実行し、その後、古い各エンティティを削除する必要があるため、エンティティの数が多い場合、この方法ではコストと時間がかかる可能性があります。複数の削除要求をバッチ処理として EGT にまとめることで、古いエンティティを削除するのに必要なサーバーへのラウンド トリップの回数を減らすことができます。  

#### ソリューション  

ログイン試行の日付ごとに異なるテーブルを使用します。上のエンティティのデザインを使用すると、エンティティを挿入する際にホットスポットを回避できます。毎日数百や数千もの個々のログイン エンティティを検索して削除する代わりに、毎日テーブルを 1 つ削除する (単一のストレージ操作) だけで古いエンティティを削除できます。  

#### 問題と注意事項  

このパターンの実装方法を決めるときには、以下の点に注意してください。  

-	特定のエンティティの検索、他のデータとのリンク、集計情報の生成など、データの他の用途もサポートするように設計していますか。  
-	新しいエンティティを挿入する際にホットスポットを回避するように設計していますか。  
-	テーブル名を削除した後に同じテーブル名を再利用する場合に遅延が必要であります。常に一意のテーブル名を使用することをお勧めします。  
-	Table サービスではアクセス パターンを学習して、ノード全体にパーティションを分散しますが、最初に新しいテーブルを使用するときは何らかの調整が行われます。新しいテーブルを作成する必要がある頻度を検討する必要があります。  

#### このパターンを使用する状況  

同時に削除する必要があるエンティティが大量にある場合に、このパターンを使用します。  

#### 関連のあるパターンとガイダンス  

このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

-	[エンティティ グループ トランザクション](#entity-group-transactions)
-	[エンティティを変更する](#working-with-heterogeneous-entity-types)  

### データ系列パターン  

データ系列全体を単一のエンティティに格納し、要求の数を最小限に抑えます。  

#### コンテキストと問題  

一般的なシナリオとして、通常、アプリケーションで一度にすべて取得する必要があるデータ系列を格納するというものがあります。たとえば、アプリケーションで 1 時間ごとに各従業員が送信した IM メッセージの数を記録し、後でその情報を使用して、各ユーザーが過去 24 時間以内に送信したメッセージの数をプロットするとします。設計の 1 つとして、従業員ごとに 24 個のエンティティを格納します。  

![][22]
 
この設計では、アプリケーションでメッセージのカウント値を更新する必要があるときに、各従業員の更新するエンティティを簡単に検索して更新できます。ただし、情報を取得して、過去 24 時間の活動のグラフをプロットするためには、24 個のエンティティを取得する必要があります。  

#### ソリューション  

次のデザインを使用し、各時間のメッセージ数をそれぞれ別のプロパティに格納します。  

![][23]
 
この設計では、マージ操作を使用して、特定の時間の従業員のメッセージ数を更新できます。これで、単一のエンティティに対する単一の要求を使用して、チャートをプロットするために必要なすべての情報を取得できます。  

#### 問題と注意事項  

このパターンの実装方法を決めるときには、以下の点に注意してください。  
-	データ系列全体が単一のエンティティに収まらない場合 (エンティティは最大 252 個のプロパティを持つことができます)、BLOB などの代わりのデータ ストアを使用します。  
-	複数のクライアントが同時にエンティティを更新する場合は、**ETag** を使用して、オプティミスティック同時実行を実装する必要があります。クライアントがたくさんある場合は、競合が大量に発生する可能性があります。  

#### このパターンを使用する状況  

個々のエンティティに関連付けられているデータ系列を更新したり取得したりする必要がある場合に、このパターンを使用します。  

#### 関連のあるパターンとガイダンス  

このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

-	[ラージ エンティティ パターン](#large-entity-pattern)  
-	[マージまたは置換](#working-with-heterogeneous-entity-types)  
-	[最終的に一貫性のあるトランザクション パターン](#eventually-consistent-transactions-pattern) (データ系列を BLOB に格納する場合)  

### ワイド エンティティ パターン  

複数の物理エンティティを使用して、252 を超えるプロパティを持つ論理エンティティを格納します。  

#### コンテキストと問題  

個々のエンティティが持つことができるプロパティは、(必須のシステム プロパティを除き) 252 個までです。また、格納できるデータは合計で 1 MB までです。リレーショナル データベースでは、通常、新しいテーブルを追加し、その新しいテーブルと 1 対 1 のリレーションシップを作成することによって、行のサイズに関するさまざまな制限を回避します。  

#### ソリューション  

Table サービスを使用すると、複数のエンティティを格納して、252 を超えるプロパティを持つ単一の大きなビジネス オブジェクトを作成できます。たとえば、過去 365 日の間に各従業員が送信した IM メッセージの数を格納する場合は、スキーマの異なる 2 つのエンティティを使用する次のデザインを使用できます。  

![][24]
 
両方のエンティティを更新しないとエンティティどうしの同期が維持されない変更を加える必要がある場合は、EGT を使用できます。それ以外の場合は、単一のマージ操作を使用して、特定の日のメッセージ数を更新できます。個々の従業員のデータをすべて取得するには、両方のエンティティを取得する必要があります。この操作は、**PartitionKey** 値と **RowKey** 値の両方を使用する 2 つの効率的な要求で実行できます。  

#### 問題と注意事項  

このパターンの実装方法を決めるときには、以下の点に注意してください。  

-	論理エンティティ全体を取得するには、少なくとも 2 つのストレージ トランザクション (各物理エンティティを取得するトランザクション) が必要です。  

#### このパターンを使用する状況  

サイズやプロパティの数が Table サービスの個々のエンティティの制限を超えるエンティティを格納する必要がある場合に、このパターンを使用します。  

#### 関連のあるパターンとガイダンス  

このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

-	[エンティティ グループ トランザクション](#entity-group-transactions)
-	[マージまたは置換](#working-with-heterogeneous-entity-types)

### ラージ エンティティ パターン  

BLOB ストレージを使用して、大きなプロパティ値を格納します。  

#### コンテキストと問題  

個々のエンティティに格納できるデータは合計で 1 MB までです。1 つまたは複数のプロパティに格納される値でエンティティの合計サイズが 1 MB を超える場合は、Table サービスにエンティティ全体は格納できません。  

#### ソリューション  

1 つ以上のプロパティに大量のデータが含まれているためにエンティティのサイズが 1 MB を超える場合は、BLOB サービスにデータを格納し、エンティティのプロパティに BLOB のアドレスを格納できます。たとえば、BLOB ストレージに従業員の写真を格納し、従業員エンティティの **Photo** プロパティに写真のリンクを格納できます。  

![][25] 

#### 問題と注意事項  

このパターンの実装方法を決めるときには、以下の点に注意してください。  

-	Table サービスのエンティティと BLOB サービスのデータの一貫性を最終的に確保する場合は、[最終的に一貫性のあるトランザクション パターン]を使用して、(#eventually-consistent-transactions-pattern) エンティティを管理します。    
-	エンティティ全体を取得するには、少なくとも 2 つのストレージ トランザクション (エンティティを取得するトランザクションと BLOB データを取得するトランザクション) が必要です。  

#### このパターンを使用する状況  

サイズが Table サービスの個々のエンティティの制限を超えるエンティティを格納する必要がある場合に、このパターンを使用します。  

#### 関連のあるパターンとガイダンス  

このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

-	[最終的に一貫性のあるトランザクション パターン](#eventually-consistent-transactions-pattern)  
-	[ワイド エンティティ パターン](#large-entity-pattern)

### 先頭または末尾に追加するアンチパターン  

大量に挿入する場合に、挿入を複数のパーティションに分散させることで、スケーラビリティを向上させます。  

#### コンテキストと問題  

格納されているエンティティの先頭または末尾にエンティティを追加すると、通常は、連続するパーティションの最初または最後のパーティションに新しいエンティティが追加されます。この場合、常に挿入はすべて同じパーティション内で行われるため、ホットスポットが発生し、Table サービスが複数のノードに挿入の負荷を分散できず、場合によっては、パーティションのスケーラビリティ ターゲットに達する可能性があります。たとえば、従業員によるネットワークやリソースへのアクセスをログに記録するアプリケーションで以下に示すエンティティ構造を使用した場合、トランザクションの量が個々のパーティションのスケーラビリティ ターゲットに達すると、現在処理が行われているパーティションがホットスポットになる可能性があります。  

![][26]
 
#### ソリューション  

代わりに次のエンティティ構造を使用すると、アプリケーションでイベントをログに記録する際に特定のパーティションのホットスポットを回避できます。  

![][27]

この例では、**PartitionKey** と **RowKey** の両方が複合キーになっていることに注目してください。**PartitionKey** では、複数のパーティションにログを分散するために、部署と従業員 ID の両方を使用しています。  

#### 問題と注意事項  

このパターンの実装方法を決めるときには、以下の点に注意してください。  

-	挿入時のホット パーティションの発生を回避する代わりのキー構造でクライアント アプリケーションが実行するクエリを効率的にサポートしていますか。  
-	予想されるトランザクションの量から判断して、個々のパーティションのスケーラビリティ ターゲットに達し、ストレージ サービスによって調整される可能性がありますか。  

#### このパターンを使用する状況  

トランザクションの量により、ホット パーティションにアクセスするとストレージ サービスによって調整される可能性がある場合は、先頭または末尾に追加するアンチパターンを使用しないでください。  

#### 関連のあるパターンとガイダンス  

このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

-	[複合キー パターン](#compound-key-pattern)  
-	[ログ テール パターン](#log-tail-pattern)  
-	[エンティティを変更する](#working-with-heterogeneous-entity-types)  

### ログ データのアンチパターン  

ログ データの格納には通常、Table サービスではなく BLOB サービスを使用します。  

#### コンテキストと問題  

ログ データを使用する局面として最も一般的なのが、特定の日付範囲または時間範囲のログ エントリを選択して取得するというものです。たとえば、特定の日の 15:04 から 15:06 までの間にアプリケーションが記録したエラー メッセージや重要なメッセージをすべて取得するなどの局面が挙げられます。ところが、ログ エンティティの保存先となるパーティションを決める基準としてログ メッセージの日付と時刻を使用しないこともあります。その場合、特定の時点で全部のエンティティが同じ **PartitionKey** の値を共有することになるため、ホット パーティションが発生することになります (「[先頭または末尾に追加するアンチパターン]」をご覧ください(#prepend-append-anti-pattern))。たとえば、ログ メッセージに関する以下のエンティティ スキーマでは、アプリケーションが現在の日付や時刻についてパーティションにあらゆるログ メッセージを書き込むことになるため、ホット パーティションの問題が発生します。  

![][28]
 
この例では、**RowKey** にログ メッセージの日付や時刻が格納されているため、ログ メッセージが日付/時刻の順序に並んで保存されます。また、複数のログ メッセージが同じ日付と時刻を共有している場合には、RowKey にほかにもメッセージ ID が格納されます。  

もう 1 つのアプローチには、アプリケーションが複数のパーティションをまたいでメッセージを書き込めるような **PartitionKey** を使用するという方法があります。たとえば、ログ メッセージのソースで多数のパーティションにメッセージを配信できるようになっている場合には、以下のエンティティ スキーマを使用できます。  

![][29]
 
ただし、このスキーマには問題があります。特定のタイム スパンに記録されたログ メッセージをすべて取得するときには、テーブル内のパーティションを逐一検索する必要があるからです。

#### ソリューション  

前のセクションでは、ログ エントリの保存先として Table サービスを使用した場合に生じる問題について説明し、その解決策として、完璧とは言いがたいものの 2 つの設計を紹介しました。1 つ目に紹介した方法には、ホット パーティションが発生し、ログ メッセージの書き込みのパフォーマンスが低下するリスクがあります。これに対して 2 つ目の方法は、特定のタイム スパンについてログ メッセージを取得しようとした場合に、テーブル内のパーティションを逐一スキャンしなければならないため、クエリのパフォーマンスが低下するという問題がありました。BLOB ストレージなら、ここで取り上げたシナリオについて前の 2 つよりも優れたソリューションとなることができます。このため、Azure Storage Analytics が収集したログ データを保存するときにも、この BLOB ストレージが使用されています。  

このセクションでは、Storage Analytics が BLOB ストレージにログ データを格納する流れの概要を説明し、範囲を指定してクエリを実行することが多いデータを保存する際にこのアプローチがどのように役立つかを見ていきます。  

Storage Analytics では、ログ メッセージを一定の形式で区切ったものを、複数の BLOB に格納します。区切りに使用する形式は、クライアント アプリケーション側でログ メッセージのデータ解析を円滑に完了できるものになっています。  

Storage Analytics が BLOB に対して使用している名前付け規則は、検索対象のログ メッセージが含まれる BLOB の場所を特定できるようなものになっています。たとえば、"queue/2014/07/31/1800/000001.log" という名前の BLOB であれば、2014 年 7 月 31 日の 18:00 から始まる時間の Queue サービスと関係があるログ メッセージが格納されています。"000001" という部分は、この期間の最初のログ ファイルであることを示しています。このほか、Storage Analytics では BLOB のメタデータの一環として、ファイルに保存されている最初と最後のログ メッセージのタイムスタンプを記録します。BLOB ストレージの API では、一定の名前プレフィックスに基づいてコンテナー内の BLOB の場所を特定できるようになっています。18:00 から始まる時間についてキューのログ データを格納している BLOB をすべて検索する場合には、"queue/2014/07/31/1800" というプレフィックスを使用します。  

Storage Analytics は内部のバッファーにログ メッセージを保管したうえで、ログ エントリのバッチの最新版を使って定期的に BLOB を更新したり、新しい BLOB を作成したりします。これによって、BLOB サービスに書き込みを実行する回数が少なくなります。  

アプリケーションにこれと似たソリューションを実装するときには、信頼性 (ログ エントリが発生するたびに BLOB ストレージに書き込む) と、コストとスケーラビリティ (アプリケーションに更新内容を一時的に保管し、バッチとして BLOB ストレージに書き込む) との間のトレードオフをどのようにするかについて、検討が必要になります。  

#### 問題と注意事項  

ログ データの保存方法を決めるときには、以下の点に注意する必要があります。  

-	ホット パーティションが発生しないような設計のテーブルを作成すると、ログ データに対するアクセス効率が低下することがあります。  
-	ログ データを処理するときには多くの場合、クライアント側で多くのレコードを読み込む必要があります。  
-	ログ データは構造化されていないことが多いものの、BLOB ストレージの方が優れたソリューションになることがあります。  

### 実装時の注意事項  

このセクションでは、ここまでのセクションで説明したパターンを実装する際に念頭に置く必要がある点をいくつか説明します。このセクションで示したコード例は、ほとんどが C# で書かれ、ストレージ クライアント ライブラリ (本稿執筆時点のバージョンは 4.3.0) を使用しています。  

### エンティティを取得する  

「[クエリに対応した設計](#design-for-querying)」のセクションで説明したとおり、効率という面で最も優れたクエリは、ポイント クエリです。ただ、時として多数のエンティティを同時に取得することも必要になります。このセクションでは、ストレージ クライアント ライブラリを使ってエンティティを取得するときによく使用される方法をいくつか紹介します。  

#### ストレージ クライアント ライブラリを使ってポイント クエリを実行する  

ポイント クエリを実行するうえで最も簡単な方法は、テーブル 操作 **Retrieve** を使用することです。以下の C# コード スニペットをご覧ください。このコードでは、**PartitionKey** の値が "Sales" で **RowKey** の値が "212" のエンティティを取得できます。  

	TableOperation retrieveOperation = 
		TableOperation.Retrieve<EmployeeEntity>("Sales", "212");
	var retrieveResult = employeeTable.Execute(retrieveOperation);
	if (retrieveResult.Result != null)
	{
    EmployeeEntity employee = (EmployeeEntity)retrieveResult.Result;
    ...
	}  

この例では、取得するエンティティの型が **EmployeeEntity** となっています。  

#### LINQ を使って複数のエンティティを取得する  

LINQ とストレージ クライアント ライブラリを使用し、**where** 句を使ってクエリを指定すると、複数のエンティティを取得できます。テーブル スキャンを回避するには、where 句に必ず **PartitionKey** の値を指定します。可能であれば **RowKey** の値も指定すると、テーブル スキャンのほかにパーティション スキャンも回避できます。Table サービスは、where 句で一部の比較演算子 (より大きい、以上、より小さい、以下、等しい、等しくない) のみサポートしています。以下の C# コード スニペットは、営業部に所属し、姓が "B" で始まる従業員全員を特定するものです (ここでは **RowKey** に姓、**PartitionKey** に所属部署名が、それぞれあるものとします)。  

	TableQuery<EmployeeEntity> employeeQuery = 
  			employeeTable.CreateQuery<EmployeeEntity>();
	var query = (from employee in employeeQuery
                where employee.PartitionKey == "Sales" &&
                employee.RowKey.CompareTo("B") >= 0 &&
                employee.RowKey.CompareTo("C") < 0
                select employee).AsTableQuery();
	var employees = query.Execute();  

クエリにはパフォーマンス向上のため、**RowKey** と **PartitionKey** が 2 つとも指定されています。  

以下のコード サンプルは、fluent API を使って上のコードと同等の機能を実現したものです (fluent API 全般について詳しくは、「[fluent API の設計に関するベスト プラクティス](http://visualstudiomagazine.com/articles/2013/12/01/best-practices-for-designing-a-fluent-api.aspx)」をご覧ください)。  

	TableQuery<EmployeeEntity> employeeQuery = new TableQuery<EmployeeEntity>().Where(
 	 TableQuery.CombineFilters(
    	TableQuery.CombineFilters(
      	TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales"),
      TableOperators.And,
      TableQuery.GenerateFilterCondition(
        "RowKey", QueryComparisons.GreaterThanOrEqual, "B")
    ),
    TableOperators.And,
    TableQuery.GenerateFilterCondition("RowKey", QueryComparisons.LessThan, "C")
 	 )
	);
	var employees = employeeTable.ExecuteQuery(employeeQuery);  


>[AZURE.NOTE] このサンプルでは、複数の **CombineFilters** メソッドを入れ子にしたうえで、3 つのフィルター条件を設定しています。  

#### 1 件のクエリで大量のエンティティを取得する  

最適化したクエリでは、**PartitionKey** と **RowKey** の値に基づいて個々のエンティティを 1 つずつ返します。ところが、場合によっては同じパーティション、ときには多数のパーティションから、多数のエンティティを返すことが必要になります。  

そのようなときには必ず、アプリケーションのパフォーマンスを綿密にテストする必要があります。  

Table サービスに対してクエリを実行した場合、一度に返されるエンティティの数は最大 1,000 件、クエリの実行時間は最大 5 秒間です。結果として返されるエンティティが 1,000 件を超える場合、クエリが 5 秒以内に完了しなかった場合、またはクエリがパーティションの境界をまたいで実行される場合には、Table サービスによって継続トークンが返されます。クライアント アプリケーションはこのトークンを使って、続きとなるエンティティを要求します。継続トークンの動作に関する詳細については、MSDN の「[クエリのタイムアウトと改ページ](http://msdn.microsoft.com/library/azure/dd135718.aspx)」をご覧ください。  

ストレージ クライアント ライブラリを使用している場合には、Table サービスからエンティティが返されるたびに継続トークンが自動で処理されます。以下の C# コード サンプルではストレージ クライアント ライブラリを使用しているため、Table サービスが応答で返した継続トークンが自動的に処理されます。  

	string filter = TableQuery.GenerateFilterCondition(
  		"PartitionKey", QueryComparisons.Equal, "Sales");
	TableQuery<EmployeeEntity> employeeQuery =
  		new TableQuery<EmployeeEntity>().Where(filter);

	var employees = employeeTable.ExecuteQuery(employeeQuery);
	foreach (var emp in employees)
	{
  		...
	}  

以下の C# コード サンプルでは、継続トークンの処理を明示的に記述しています。  

	string filter = TableQuery.GenerateFilterCondition(
  		"PartitionKey", QueryComparisons.Equal, "Sales");
	TableQuery<EmployeeEntity> employeeQuery =
  		new TableQuery<EmployeeEntity>().Where(filter);

	TableContinuationToken continuationToken = null;

	do
	{
  		var employees = employeeTable.ExecuteQuerySegmented(
    		employeeQuery, continuationToken);
  	foreach (var emp in employees)
  	{
   	 ...
  	}
  	continuationToken = employees.ContinuationToken;
	} while (continuationToken != null);  

継続トークンを明示的に使用すると、アプリケーションが次のセグメントに相当するデータを取得するタイミングを制御ができます。たとえば、テーブルに格納されたエンティティをクライアント アプリケーションでページとして表示できるようにしている場合に、クエリで取得したエンティティをユーザーが最後まで見ないことがあります。そのようなとき、継続トークンを明示的に使用していれば、ユーザーが現在のセグメントのエンティティの最後のページに達した時点で、アプリケーションが継続トークンだけを使って次のセグメントを取得できます。この方法には、いくつかの利点があります。  

-	Table サービスから取得するデータの量を制限したり、ユーザーがネットワークを移動したりできるようになります。  
-	.NET の非同期 IO を実行できるようになります。  
-	継続トークンをシリアル化して永続記憶装置に保存できるため、アプリケーションがクラッシュした場合でも処理を継続できるようになります。  

>[AZURE.NOTE] 継続トークンは通常、エンティティ 1,000 件を 1 つのセグメントにして返しますが、この数が少なくなることもあります。このことは、1 件のクエリによって返されるエントリの数に上限を設けた場合にも当てはまります。**Take** を使用すると、ルックアップ基準に合致するエンティティが任意の数だけ返されるようになります。Table サービスでは、セグメントとして返されるエンティティの数が指定よりも少なくなることがありますが、その場合には、残りのエンティティを取得できるように、併せて継続トークンが返されます。  

以下の C# コードは、1 つのセグメントで返されるエンティティの数を変更するためのものです。  

	employeeQuery.TakeCount = 50;  

#### サーバー側のプロジェクション  

1 つのエンティティには最大で 255 個のプロパティを格納でき、エンティティの最大サイズは 1 MB です。テーブルに対してクエリを実行してエンティティを取得する際、すべてのプロパティが必要ない場合は、データの不要な転送を避けることができます (遅延とコストの削減につながります)。サーバー側のプロジェクションを使えば、必要なプロパティのみを転送できます。次の例では、クエリで選択されたエンティティから **Email** プロパティのみ (それに加えて **PartitionKey**、**RowKey**、**Timestamp**、**ETag**) を取得しています。  

	string filter = TableQuery.GenerateFilterCondition(
  		"PartitionKey", QueryComparisons.Equal, "Sales");
	List<string> columns = new List<string>() { "Email" };
	TableQuery<EmployeeEntity> employeeQuery =
  		new TableQuery<EmployeeEntity>().Where(filter).Select(columns);

	var entities = employeeTable.ExecuteQuery(employeeQuery);
	foreach (var e in entities)
	{
  		Console.WriteLine("RowKey: {0}, EmployeeEmail: {1}", e.RowKey, e.Email);
	}  

**RowKey** 値は、取得対象のプロパティの一覧に含まれていなくても使用できることがわかります。  

### エンティティを変更する  

ストレージ クライアント ライブラリを使えば、Table サービスに格納されたエンティティを、挿入、削除、更新の各操作によって変更できます。また、EGT を使えば複数の挿入、更新、削除の操作を一括で行えるため、必要なラウンドトリップの回数が減り、ソリューションのパフォーマンスが高まります。  

ストレージ クライアント ライブラリが EGT を実行したときにスローされる例外には、通常、一括処理の失敗を招いたエンティティのインデックスが含まれます。これは EGT を使うコードをデバッグする際に役立ちます。  

クライアント アプリケーションでの同時実行と更新操作の処理方法に設計が及ぼす影響についても考慮が必要です。  

#### 同時実行を管理する  

既定では、Table サービスには、個々のエンティティのレベルで **Insert**、**Merge**、**Delete** 操作についてオプティミスティック同時実行チェックが実装されます。ただし、クライアントが Table サービスでこれらのチェックを強制的にバイパスさせることもできます。Table サービスでの同時実行の管理方法については、Microsoft Azure の Web サイトで「[Microsoft Azure Storage での同時実行制御の管理]」(../storage-concurrency/) をご覧ください。  

#### マージまたは置換  

**TableOperation** クラスの **Replace** メソッドは、Table サービス内の完全なエンティティを置き換えます。格納されたエンティティに存在するプロパティを要求に含めない場合、要求により、格納されたエンティティからそのプロパティが削除されます。格納されたエンティティからプロパティを明示的に削除しない場合は、すべてのプロパティを要求に含める必要があります。  

**TableOperation** クラスの **Merge** メソッドを使えば、エンティティを更新する際に Table サービスに送信するデータの量を減らすことができます。**Merge** メソッドは、格納されたエンティティ内のすべてのプロパティを、要求に含まれるエンティティのプロパティ値に置き換えますが、要求に含まれていないもののプロパティはそのまま残します。ラージ エンティティがあり、要求で少数のプロパティのみを更新する必要があるときに便利な処理です。  

>[AZURE.NOTE] エンティティが存在しない場合、**Replace** メソッドと **Merge** メソッドは失敗します。代わりに、**InsertOrReplace** メソッドと **InsertOrMerge** メソッドを使用すれば、エンティティが存在しない場合に新たに作成できます。  

### 異なる種類のエンティティを操作する  

Table サービスは  *schema-less* テーブル ストアです。1 つのテーブルに複数の種類のエンティティを格納できるため、非常に柔軟な設計が可能です。次の例は、従業員エンティティと部署エンティティの両方を格納したテーブルを示しています。  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>Timestamp</th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>	 	 	 

各エンティティに **PartitionKey** 値、**RowKey** 値、**Timestamp** 値が必要ですが、プロパティのセットがある可能性があります。さらに、エンティティの種類を示すものがありません (エンティティの種類に関する情報を格納していない場合)。エンティティの種類を識別する方法は 2 とおりあります。  

-	**RowKey** (または **PartitionKey**) の先頭にエンティティの種類を追加します。たとえば、 **RowKey** 値を **EMPLOYEE_000123** または **DEPARTMENT_SALES** のようにします。  
-	以下の表に示すように、個別のプロパティを使用してエンティティの種類を記録します。  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>Timestamp</th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Employee</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Employee</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td>Department</td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Employee</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>	 	 	 	 

エンティティの種類を **RowKey** の先頭に追加する最初の方法は、異なる種類の 2 つのエンティティに同じキー値が含まれる可能性がある場合に便利です。この方法なら、パーティションに同じ種類のエンティティのグループ化もできます。  
 
このセクションで説明した手法は、「[I継承のリレーションシップ]」(#inheritance-relationships) のセクション[リレーションシップのモデル化]の記述と同様です(#modelling-relationships)。  

>[AZURE.NOTE] エンティティの種類の値にバージョン番号を追加して、クライアント アプリケーションで POCO オブジェクトを発展させ、さまざまなバージョンを操作できるようにすることを検討してください。  

このセクションの残りの部分では、同じテーブル内の異なる種類のエンティティを操作しやすくするストレージ クライアント ライブラリの機能について説明します。  

#### 異なる種類のエンティティを取得する  

ストレージ クライアント ライブラリを使えば、3 とおりの方法で複数の種類のエンティティを操作できます。  

格納されているエンティティの種類が **RowKey** 値と **PartitionKey** 値からわかる場合は、種類を指定したうえでエンティティを取得できます。**EmployeeEntity** という種類のエンティティを取得する、前の 2 つの例をご覧ください。[ストレージ クライアント ライブラリを使って 1 つのエンティティを取得する](#retrieving-a-single-entity-using-the-storage-client-library) と [LINQ を使って複数のエンティティを取得する](#retrieving-multiple-entities-using-linq)。  

2 つ目の方法は、具象的な POCO エンティティの種類ではなく **DynamicTableEntity** 型 (プロパティ バッグ) を使う方法です (この方法なら、エンティティを .NET の型にシリアル化や逆シリアル化する必要がないため、パフォーマンスも高まる可能性があります)。次の C# コードでは、テーブルから異なる種類のエンティティを複数取得できますが、すべてのエンティティが **DynamicTableEntity** インスタンスとして返されます。さらに、**EventType** プロパティを使って各エンティティの種類が判断されます。  

	string filter = 	TableQuery.CombineFilters(
    	TableQuery.GenerateFilterCondition("PartitionKey",
      QueryComparisons.Equal, "Sales"),
    	TableOperators.And,
    	TableQuery.CombineFilters(
        TableQuery.GenerateFilterCondition("RowKey", 
          			QueryComparisons.GreaterThanOrEqual, "B"),
        	TableOperators.And,
        	TableQuery.GenerateFilterCondition("RowKey", 
          QueryComparisons.LessThan, "F")
        )
    );
	TableQuery<DynamicTableEntity> entityQuery =
  	new TableQuery<DynamicTableEntity>().Where(filter);
	var employees = employeeTable.ExecuteQuery(entityQuery);

	IEnumerable<DynamicTableEntity> entities = employeeTable.ExecuteQuery(entityQuery);
	foreach (var e in entities)
	{
    EntityProperty eventTypeProperty;
    if (e.Properties.TryGetValue("EntityType", out eventTypeProperty))
    {
        if (eventTypeProperty.StringValue == "Employee")
        {
            // Use eventTypeProperty, RowKey, PartitionKey, Etag, and Timestamp
      	  }
   	 }
	}  

ただし、他のプロパティを取得するには、**DynamicTableEntity** クラスの **Properties** プロパティで **TryGetValue** メソッドを使用する必要があります。  

3 つ目の方法は、**DynamicTableEntity** 型と **EntityResolver** インスタンスを組み合わせて使用する方法です。この方法なら、同じクエリで複数の POCO 型を解決できます。この例では、**EntityResolver** デリゲートで **EventType** プロパティを使って、クエリから返されるエンティティの 2 つの種類を識別しています。**Resolve** メソッドは、**resolver** デリゲートを使って **DynamicTableEntity** インスタンスを **TableEntity** インスタンスに解決します。  

	EntityResolver<TableEntity> resolver = (pk, rk, ts, props, etag) =>
	{
  
  		TableEntity resolvedEntity = null;
  		if (props["EntityType"].StringValue == "Department")
  		{
    		resolvedEntity = new DepartmentEntity();
  		}
  		else if (props["EntityType"].StringValue == "Employee")
  		{
    		resolvedEntity = new EmployeeEntity();
  		}
  		else throw new ArgumentException("Unrecognized entity", "props");

  		resolvedEntity.PartitionKey = pk;
  		resolvedEntity.RowKey = rk;
  		resolvedEntity.Timestamp = ts;
  		resolvedEntity.ETag = etag;
  		resolvedEntity.ReadEntity(props, null);
  		return resolvedEntity;
	};

	string filter = TableQuery.GenerateFilterCondition(
  		"PartitionKey", QueryComparisons.Equal, "Sales");
	TableQuery<DynamicTableEntity> entityQuery =
  		new TableQuery<DynamicTableEntity>().Where(filter); 

	var entities = employeeTable.ExecuteQuery(entityQuery, resolver); 
	foreach (var e in entities)
	{
  		if (e is DepartmentEntity)
  		{
    	...
  		}
  		if (e is EmployeeEntity)
  		{
    	...
  		}
	}  

#### 異なる種類のエンティティを変更する  

エンティティの種類がわからなくても削除はできますが、挿入はできません。ただし、**DynamicTableEntity** 型を使えば、型を把握したり POCO エンティティ クラスを使用したりしなくても、エンティティを更新できます。次のコード サンプルでは、1 つのエンティティを取得し、更新の前に **EmployeeCount** プロパティが存在することを確認します。  

	TableResult result = 
  		employeeTable.Execute(TableOperation.Retrieve(partitionKey, rowKey));
	DynamicTableEntity department = (DynamicTableEntity)result.Result;

	EntityProperty countProperty;

	if (!department.Properties.TryGetValue("EmployeeCount", out countProperty))
	{
  		throw new 
    		InvalidOperationException("Invalid entity, EmployeeCount property not found.");
	}
	countProperty.Int32Value += 1;
	employeeTable.Execute(TableOperation.Merge(department));  

### Shared Access Signature を使ってアクセスを制御する  

Shared Access Signature (SAS) トークンを使うと、クライアント アプリケーションで、Table サービスに対して直接認証しなくてもテーブル エンティティを直接変更 (と照会) できるようになります。通常、アプリケーションで SAS を使うと、次の 3 つのメリットが得られます。  

-	デバイスで Table サービスのエンティティにアクセスして変更できるようにするために、安全ではないプラットフォーム (モバイル デバイスなど) にストレージ アカウント キーを配布する必要がない。  
-	Web ロールまたは worker ロールがエンティティを管理する際に実行する処理の一部を、エンド ユーザー コンピューターやモバイル デバイスなどのクライアント デバイスにオフロードできる。  
-	制約と時間制限のあるアクセス許可のセットをクライアントに割り当てることができる (読み取り専用アクセスを特定のリソースに許可するなど)。  

Table サービスでの SAS トークンの使用の詳細については、「[共有アクセス署名、パート 1:SAS モデルについて](../storage-dotnet-shared-access-signature-part-1/)。  

ただし、Table サービスのエンティティへのアクセスをクライアント アプリケーションに付与する SAS トークンを生成する必要はあります。これは、ストレージ アカウント キーに安全にアクセスできる環境で行うようにしてください。通常は、Web ロールまたは worker ロールを使って SAS トークンを生成し、エンティティへのアクセスを必要とするクライアント アプリケーションに配布します。SAS トークンの生成とクライアントへの配布にもやはりオーバーヘッドが伴うため、特に大量に扱うシナリオでは、このオーバーヘッドを減らす最適な方法を検討する必要があります。  

テーブル内のエンティティのサブセットへのアクセスを付与する SAS トークンを生成できます。既定では、SAS トークンはテーブル全体を対象に作成するものであるものの、SAS トークンで **PartitionKey** 値の範囲へのアクセスを付与するか、**PartitionKey** 値と **RowKey** 値の範囲へのアクセスを付与するかを指定することも可能です。システムの個々のユーザーに SAS トークンが生成されるようにすれば、各ユーザーの SAS トークンによってアクセスが許可されるのは、Table サービス内にあるユーザー独自のエンティティだけになります。  

### 非同期と並列操作  

要求を複数のパーティションに分散させている場合は、非同期または並列クエリを使ってスループットとクライアントの応答性を向上させることができます。 
たとえば、テーブルに並列的にアクセスする複数の worker ロール インスタンスを使用する場合などです。個別の worker ロールで特定のパーティション セットのみを処理することも可能であるほか、テーブル内のすべてのパーティションにアクセスできる worker ロール インスタンスを複数実装することも可能です。  

クライアント インスタンスでは、ストレージ操作を非同期的に実行することでスループットを高めることができます。ストレージ クライアント ライブラリを使えば、非同期クエリと変更を簡単に記述できます。たとえば、次の C# コードに示すように、パーティション内のすべてのエントリを取得する同期メソッドをベースとして利用できます。  

	private static void ManyEntitiesQuery(CloudTable employeeTable, string department)
	{
  		string filter = TableQuery.GenerateFilterCondition(
    		"PartitionKey", QueryComparisons.Equal, department);
  		TableQuery<EmployeeEntity> employeeQuery =
    		new TableQuery<EmployeeEntity>().Where(filter); 

  		TableContinuationToken continuationToken = null;

  		do
  		{
    		var employees = employeeTable.ExecuteQuerySegmented(
      			employeeQuery, continuationToken); 
    		foreach (var emp in employees)
    	{
      	...
    	}
    		continuationToken = employees.ContinuationToken;
  		} while (continuationToken != null);
	}  

このコードを次のように少し変更して、クエリが非同期的に実行されるようにします。  

	private static async Task ManyEntitiesQueryAsync(CloudTable employeeTable, string department)
	{
  		string filter = TableQuery.GenerateFilterCondition(
    		"PartitionKey", QueryComparisons.Equal, department);
  		TableQuery<EmployeeEntity> employeeQuery =
    		new TableQuery<EmployeeEntity>().Where(filter); 
  		TableContinuationToken continuationToken = null;

  		do
  		{
    		var employees = await employeeTable.ExecuteQuerySegmentedAsync(
      			employeeQuery, continuationToken); 
    		foreach (var emp in employees)
    		{
     		 ...
    		}
    		continuationToken = employees.ContinuationToken;
  			} while (continuationToken != null);
	}  

この非同期の例は、同期のバージョンに次の変更が加えられたものです。  

-	メソッドの署名に **async** 修飾子が含まれ、**Task** インスタンスが返されるようになっています。  
-	**ExecuteSegmented** メソッドを呼び出して結果を取得する代わりに、**ExecuteSegmentedAsync** メソッドを呼び出し、**await** 修飾子を使って結果を非同期的に取得するようになっています。  

クライアント アプリケーションはこのメソッドを複数回呼び出すことができ (**department** パラメーターに異なる値を使う)、各クエリは別々のスレッドで実行されます。  

ただし、**TableQuery** クラスの **Execute** メソッドの非同期バージョンはありません。**IEnumerable** インターフェイスは非同期の列挙をサポートしていないためです。  

エンティティを非同期的に挿入、更新、削除できます。次の C# の例は、従業員エンティティを挿入または置換する単純な同期メソッドです。  

	private static void SimpleEmployeeUpsert(CloudTable employeeTable,
  		EmployeeEntity employee)
	{
  		TableResult result = employeeTable
    		.Execute(TableOperation.InsertOrReplace(employee));
  		Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
	}  

You can easily modify this code so that the update runs asynchronously as follows:  

	private static async Task SimpleEmployeeUpsertAsync(CloudTable employeeTable, 
  		EmployeeEntity employee)
	{
  		TableResult result = await employeeTable
    		.ExecuteAsync(TableOperation.InsertOrReplace(employee));
  		Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
	}  

この非同期の例は、同期のバージョンに次の変更が加えられたものです。  

-	メソッドの署名に **async** 修飾子が含まれ、**Task** インスタンスが返されるようになっています。  
-	**Execute** メソッドを呼び出してエンティティを更新する代わりに、**ExecuteAsync** メソッドを呼び出し、**await** 修飾子を使って結果を非同期的に取得するようになっています。  

クライアント アプリケーションは、これと同じように非同期メソッドを複数回呼び出すことができます。各メソッドの呼び出しは別々のスレッドで実行されます。  


### 謝辞
Azure チームの次のメンバーのご協力に感謝します:Dominic Betts、Jason Hogg、Jean Ghanem、Jai Haridas、Jeff Irwin、Vamshidhar Kommineni、Vinay Shah、Serdar Ozler  

レビュー サイクルで貴重なフィードバックを提供してくださった次の Microsoft MVP の方々にも感謝申し上げます:Igor Papirov、Edward Bakker 


 
[1]: ./media/storage-table-design-guide/storage-table-design-IMAGE01.png
[2]: ./media/storage-table-design-guide/storage-table-design-IMAGE02.png
[3]: ./media/storage-table-design-guide/storage-table-design-IMAGE03.png
[4]: ./media/storage-table-design-guide/storage-table-design-IMAGE04.png
[5]: ./media/storage-table-design-guide/storage-table-design-IMAGE05.png
[6]: ./media/storage-table-design-guide/storage-table-design-IMAGE06.png
[7]: ./media/storage-table-design-guide/storage-table-design-IMAGE07.png
[8]: ./media/storage-table-design-guide/storage-table-design-IMAGE08.png
[9]: ./media/storage-table-design-guide/storage-table-design-IMAGE09.png
[10]: ./media/storage-table-design-guide/storage-table-design-IMAGE10.png
[11]: ./media/storage-table-design-guide/storage-table-design-IMAGE11.png
[12]: ./media/storage-table-design-guide/storage-table-design-IMAGE12.png
[13]: ./media/storage-table-design-guide/storage-table-design-IMAGE13.png
[14]: ./media/storage-table-design-guide/storage-table-design-IMAGE14.png
[15]: ./media/storage-table-design-guide/storage-table-design-IMAGE15.png
[16]: ./media/storage-table-design-guide/storage-table-design-IMAGE16.png
[17]: ./media/storage-table-design-guide/storage-table-design-IMAGE17.png
[18]: ./media/storage-table-design-guide/storage-table-design-IMAGE18.png
[19]: ./media/storage-table-design-guide/storage-table-design-IMAGE19.png
[20]: ./media/storage-table-design-guide/storage-table-design-IMAGE20.png
[21]: ./media/storage-table-design-guide/storage-table-design-IMAGE21.png
[22]: ./media/storage-table-design-guide/storage-table-design-IMAGE22.png
[23]: ./media/storage-table-design-guide/storage-table-design-IMAGE23.png
[24]: ./media/storage-table-design-guide/storage-table-design-IMAGE24.png
[25]: ./media/storage-table-design-guide/storage-table-design-IMAGE25.png
[26]: ./media/storage-table-design-guide/storage-table-design-IMAGE26.png
[27]: ./media/storage-table-design-guide/storage-table-design-IMAGE27.png
[28]: ./media/storage-table-design-guide/storage-table-design-IMAGE28.png
[29]: ./media/storage-table-design-guide/storage-table-design-IMAGE29.png

<!--HONumber=47-->
